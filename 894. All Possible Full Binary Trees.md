2026-01-09 11:14

Link: https://leetcode.com/problems/all-possible-full-binary-trees/description/

Problem: 
Given an integer `n`, return _a list of all possible **full binary trees** with_ `n` _nodes_. Each node of each tree in the answer must have `Node.val == 0`.

Each element of the answer is the root node of one possible tree. You may return the final list of trees in **any order**.

A **full binary tree** is a binary tree where each node has exactly `0` or `2` children.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)

**Input:** n = 7
**Output:** [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]

**Example 2:**
**Input:** n = 3
**Output:** [[0,0,0]]

**Constraints:**
- `1 <= n <= 20`

failure: 
did not have the right idea on how to build the tree recursively, and dont know how to decide next move in each iteration , did not use the nature of the full binary tree to think of the next mov , did not know how to integrate for loop in each  iteration, did not have a mental model on how to tackle this sets of problems! did not know when to apply the cartesian products( generate all permutations  or possibilities? )

Intuitions:
the full binary tree nature told us that the tree can only be built if number of node to be used is odd number( root node consume odd number of node, and rest of the level would consume even number of nodes!).

how to use the idea of substructure? where > “For each number of nodes, I want **the set of all tree shapes** that are possible.” -> building subtrees!

A full binary tree is brutally strict:
- A node is either a **leaf** (0 children)
- Or a **fork** (2 children)
- Never 1 child

This means every non-leaf node **creates two demands**:
“Give me a left subtree and a right subtree.”

think clear on path-based or shape-based problems!  where this one is shape based ,and we have to actually construct the tree!

Summary:
A full binary tree is completely determined by how you split nodes between its left and right subtrees, so we generate all trees by recursively combining all smaller full trees whose sizes add up correctly, caching results to avoid rebuilding the same shapes. use cartesian products to generate all possibilities ( dot product )****

Solution:
```python
class Solution(object):
    def allPossibleFBT(self, n):
        if n % 2 == 0:
            return []

        dp = {}

        def dfs(num):
            if num in dp:
                return dp[num]

            if num == 1:
                return [TreeNode(0)]

            ans = []
            for l in range(1, num, 2):          # l odd
                r = num - 1 - l                 # r odd automatically
                leftTrees = dfs(l)
                rightTrees = dfs(r)

                for L in leftTrees:
                    for R in rightTrees:
                        root = TreeNode(0)
                        root.left = L
                        root.right = R
                        ans.append(root)

            dp[num] = ans
            return ans

        return dfs(n)
```

Tags: #binary_tree  #cartesian #recursion #dp #memoization 

RL: 

Considerations:
## **Why this is NOT “just brute force”**

It feels brute-force at first glance, but it’s actually minimal:
- You must output all trees
- Each output tree corresponds to **one unique (L, R) pair**
- So you must visit each pair at least once

The double loop is not wasteful — it’s **necessary work**.
```python
for each split (l, r):
    for each leftTree in F(l):
        for each rightTree in F(r):
            make a new root(leftTree, rightTree)
```

Ask yourself:
“Am I independently choosing one thing from set A and one thing from set B, and every pairing matters?”

If yes → double loop.

Here:
- A = left subtree shapes
- B = right subtree shapes
So yes, inevitably.

The double loop is where **independence becomes enumeration**: every left tree can coexist with every right tree, so the algorithm must explicitly construct all such pairings.