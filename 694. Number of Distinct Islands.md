2025-10-03 13:05

Link: https://chatgpt.com/c/68dffd6c-ce74-8326-9c51-433ab615e27c

Problem: 
You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.

Return _the number of **distinct** islands_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/01/distinctisland1-1-grid.jpg)

**Input:** grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]
**Output:** 1

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/05/01/distinctisland1-2-grid.jpg)

**Input:** grid = [[1,1,0,1,1],[1,0,0,0,0],[0,0,0,0,1],[1,1,0,1,1]]
**Output:** 3

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `grid[i][j]` is either `0` or `1`.

Intuition:
u need to record the relative sharpe for each islands ,and compare the shape with island that u newly found ,if shape is the same, new island is not distinct. we can form the shape of island by finding a reference point first, the we compute shape by getting the relative distance from neighboring cells  to the reference cell

Solution:
```python
from typing import List, Tuple, Set

class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        seen: Set[Tuple[int, int]] = set()
        shapes: Set[Tuple[Tuple[int, int], ...]] = set()
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]

        def dfs(r: int, c: int, cells: list) -> None:
            # bounds, water, or visited -> stop
            if not (0 <= r < R and 0 <= c < C): return
            if grid[r][c] == 0: return
            if (r, c) in seen: return

            seen.add((r, c))
            cells.append((r, c))

            for dr, dc in dirs:
                dfs(r + dr, c + dc, cells)

        for i in range(R):
            for j in range(C):
                if grid[i][j] == 1 and (i, j) not in seen:
                    cells = []
                    dfs(i, j, cells)

                    if not cells:
                        continue  # safety

                    # normalize to top-left (min row/col) and SORT
                    minr = min(x for x, _ in cells)
                    minc = min(y for _, y in cells)
                    rel = sorted((x - minr, y - minc) for x, y in cells)

                    # store a canonical tuple
                    shapes.add(tuple(rel))

        return len(shapes)
```

Tags: #bfs #dfs 

RL: 

Considerations:
