2025-08-18 11:00

Link: https://leetcode.com/contest/biweekly-contest-163/problems/number-of-perfect-pairs/description/

Problem: 
You are given an integer array nums.

A pair of indices (i, j) is called perfect if the following conditions are satisfied:

i < j
Let a = nums[i], b = nums[j]. Then:
min(|a - b|, |a + b|) <= min(|a|, |b|)
max(|a - b|, |a + b|) >= max(|a|, |b|)
Return the number of distinct perfect pairs.

Note: The absolute value |x| refers to the non-negative value of x.

Example 1:
Input: nums = [0,1,2,3]
Output: 2

Explanation:
There are 2 perfect pairs:
(i, j)	(a, b)	min(|a − b|, |a + b|)	min(|a|, |b|)	max(|a − b|, |a + b|)	max(|a|, |b|)
(1, 2)	(1, 2)	min(|1 − 2|, |1 + 2|) = 1	1	max(|1 − 2|, |1 + 2|) = 3	2
(2, 3)	(2, 3)	min(|2 − 3|, |2 + 3|) = 1	2	max(|2 − 3|, |2 + 3|) = 5	3

Example 2:
Input: nums = [-3,2,-1,4]
Output: 4

Explanation:
There are 4 perfect pairs:
(i, j)	(a, b)	min(|a − b|, |a + b|)	min(|a|, |b|)	max(|a − b|, |a + b|)	max(|a|, |b|)
(0, 1)	(-3, 2)	min(|-3 - 2|, |-3 + 2|) = 1	2	max(|-3 - 2|, |-3 + 2|) = 5	3
(0, 3)	(-3, 4)	min(|-3 - 4|, |-3 + 4|) = 1	3	max(|-3 - 4|, |-3 + 4|) = 7	4
(1, 2)	(2, -1)	min(|2 - (-1)|, |2 + (-1)|) = 1	1	max(|2 - (-1)|, |2 + (-1)|) = 3	2
(1, 3)	(2, 4)	min(|2 - 4|, |2 + 4|) = 2	2	max(|2 - 4|, |2 + 4|) = 6	4
Example 3:

Input: nums = [1,10,100,1000]
Output: 0

Explanation:
There are no perfect pairs. Thus, the answer is 0.

Constraints:
2 <= nums.length <= 105
-109 <= nums[i] <= 109

Intuition:
the condition can be simplified to 
![[Screenshot 2025-08-18 at 11.10.11 AM.png]]
the second cond is always true where |a| + |b| >= max(|a|, |b|) (sum is bigger than either on of the number)
the i < j cond is used to avoid duplication, and we can therefore located valid pairs faster by using binary search on the sorted values arr ,and use sliding window to determine number of valid pairs ! (we terminate the end pointer once the value of it is bigger than 2 * a[i]), and the number of valid pairs with i being the first element would be **j - (i+1)**

Solution:
```python
from bisect import bisect_right
class Solution:
    def perfectPairs(self, nums: List[int]) -> int:
        # think of precomputation, simplificaiton of conditiins, memoization and ...
        a = sorted( abs(x) for x in nums )
        n = len( a )
        cnt = 0
        for i in range( n ) : 
            j = bisect_right( a, 2 * a[i] , lo = i +1 , hi = n)
            cnt += j - (i+1)
        return cnt
```

Tags: #binary_search #sliding_window  #sorting 

RL: #biweekly-contest 

Considerations:
