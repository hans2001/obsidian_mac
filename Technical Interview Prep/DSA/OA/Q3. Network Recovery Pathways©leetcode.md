2025-08-10 22:27

Link:

Problem: 
You are given a directed acyclic graph of n nodes numbered from 0 to n − 1. This is represented by a 2D array edges of length m, where edges[i] = [ui, vi, costi] indicates a one‑way communication from node ui to node vi with a recovery cost of costi.

Some nodes may be offline. You are given a boolean array online where online[i] = true means node i is online. Nodes 0 and n − 1 are always online.

A path from 0 to n − 1 is valid if:
All intermediate nodes on the path are **online**.
The total recovery cost of all edges on the path **does not exceed k**.
For each valid path, define its score as the minimum edge‑cost along that path.

Return the maximum path score (i.e., the largest minimum-edge cost) among all valid paths. If no valid path exists, return -1.

Constraints:
n == online.length
2 <= n <= 5 * 104
0 <= m == edges.length <= min(105, n * (n - 1) / 2)
edges[i] = [ui, vi, costi]
0 <= ui, vi < n
ui != vi
0 <= costi <= 109
0 <= k <= 5 * 1013
online[i] is either true or false, and both online[0] and online[n − 1] are true.
The given graph is a directed acyclic graph

Intuition:
the idea is subtle, we binary search on the range of potential answer, since the answer want the maximum min edge cost path, we can reject path of edge that has cost bigger than x if we think x is the answer( min cost for the valid path), we could keep going up if x is valid, otherwise, we should try smaller x to try with. in each traversal, we compute distance travel so far for each path, and verify if path cost so far is smaller than or equal k( valid path requirements). we can precompute the tp sort order for minor improvement, but key idea is the find shortest path on a directed acyclic graph, so tp sort + relaxation is good enough

Solution:
```python
from collections import defaultdict,deque
class Solution:
    def findMaxPathScore(self, edges: List[List[int]], online: List[bool], k: int) -> int:
        n = len( online )
        dir = [[] for _ in range( n )]
        deg = [0] * n 
        costs = set ( )
        valid = set ( )
        for u,v,cst in edges : 
            if not online[u] or not online[v] :
                continue
            valid.add( u )
            valid.add( v )
            dir[u].append(( cst,  v ))
            deg[v] += 1 
            costs.add( cst )
        
        if not online[ 0 ] or not online[ n - 1 ] or deg[ n - 1 ] == 0:
            return -1 

        topo = []
        q = deque ([i for i in range( n ) if online[i] and deg[i] == 0 ])
        while q: 
            node = q.popleft( )
            topo.append(node)
            for cost, ne in dir[node]: 
                deg[ne] -= 1
                if deg[ne] == 0:
                    q.append( ne )
        if len (topo) < len (valid) : 
            return -1

        if not costs: 
            return -1 
        uniq = sorted( costs )

        def traverse(ans): 
            dist = [float('inf')] * n 
            dist[0] = 0
            for node in topo: 
                if dist[node] > k :
                    continue
                for cost, ne in dir[node] :
                    if cost < ans: 
                        continue
                    nd = dist[node] + cost 
                    if dist[ne] > nd and nd <= k :
                        dist[ne] = dist[node] + cost
            return dist[n-1] <= k
        
        l,r = 0, len( uniq ) -1
        res = -1
        while l <= r: 
            md = (l+r)//2
            if traverse ( uniq[md] ) : 
                res = uniq[md] 
                l = md + 1
            else: 
                r = md - 1
        return res
```

Tags: #biweekly-contest #topological_sort #deque 

RL: 

Considerations:
