2025-08-31 15:53

Link: https://leetcode.com/problems/recover-binary-search-tree/?envType=company&envId=tiktok&favoriteSlug=tiktok-three-months

Problem: 
You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. _Recover the tree without changing its structure_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)

**Input:** root = [1,3,null,null,2]
**Output:** [3,1,null,null,2]
**Explanation:** 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)

**Input:** root = [3,1,4,null,null,2]
**Output:** [2,1,4,null,null,3]
**Explanation:** 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.

**Constraints:**
- The number of nodes in the tree is in the range `[2, 1000]`.
- `-231 <= Node.val <= 231 - 1`

**Follow up:** A solution using `O(n)` space is pretty straight-forward. Could you devise a constant `O(1)` space solution?

Intuition:
inorder for valid BST gives ascending seq. as we compare previous visited node and current node at inorder position, we know that something is wrong, which make it not a binary tree.
- `first` = the **left element of the first inversion** (the earliest too-large value), and
- `second` = the **right element of the last inversion** (the latest too-small value).

**2) Why don’t we change `first` after the first inversion?**  
`first` must be the **earliest** element that’s too big—i.e., the left side of the **first** break in sorted order. Changing it later would move it rightward and break correctness in the two-inversion case.

**3) Is `prev` always the previous node visited?**  
Yes. During inorder (Left → Node → Right), `prev` is the node you visited immediately before `curr`. You update `prev = curr` after handling `curr`.

Solution:
```python
class Solution:
    def recoverTree(self, root: TreeNode) -> None:
        def find_two_swapped(root: TreeNode):
            nonlocal x, y, pred
            if root is None:
                return

            find_two_swapped(root.left)
            if pred and root.val < pred.val:
                y = root
                # The first swap occurence
                if x is None:
                    x = pred
                # The second swap occurence
                else:
                    return
            pred = root
            find_two_swapped(root.right)

        x = y = pred = None
        find_two_swapped(root)
        x.val, y.val = y.val, x.val
```

Tags: #binary_search_tree #recursion  #in_order #sorting 

RL: 

Considerations:
