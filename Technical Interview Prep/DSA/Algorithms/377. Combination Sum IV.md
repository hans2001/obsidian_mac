2025-05-02 22:14

Link: https://leetcode.com/problems/combination-sum-iv/description/

Problem: 
Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.

The test cases are generated so that the answer can fit in a **32-bit**integer.

Intuition:
recurrence: 
combs(target)=∑i=0 n​combs(target−nums[i]) if target≥nums[i]

number of combinations(permutations) to reach **remain** with values from nums! 
consider that as a subproblem, the first subproblem we need to solve is number of ways to reach 0, then to find out number of way to reach X amount, we aggregate (X - num) for all num in nums, basically it mean by adding current num to the previous combo at (X-num) we can reach X, so number of combo that reached X-num will be inherited! 

Solution:
top down DP: 
```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # potential optimization
        # nums.sort()

        @functools.lru_cache(maxsize = None)
        def combs(remain):
            if remain == 0:
                return 1

            result = 0
            for num in nums:
                if remain - num >= 0:
                    result += combs(remain - num)
                # potential optimization
                # else:
                #     break

            return result

        return combs(target)
```

bottom up DP
```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # minor optimization
        # nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1

        for comb_sum in range(target+1):
            for num in nums:
                if comb_sum - num >= 0:
                    dp[comb_sum] += dp[comb_sum-num]
                # minor optimization, early stopping.
                # else:
                #    break
        return dp[target]
```

Complexity:
Time; 
recursive stack could score up to T problems, where T is value of target.
for each recursive function, we take O(n) time to traverse the nums array! 
Same for bottom up: nested for loop over T and nested N

Space; 
O(T) space for the recursive stack and the cache
O(T) for the dp arr! 

Tags: #1d_dp #unbounded_knapsack 

RL: [[Coin Change]]

Considerations:
complete and non-redundant solutions? for proving solution correctness

- By complete, our solution will cover all valid combinations. If there is ever a combination that ends with a specific number, it would then be included in our solution.
    
- By non-redundant, each of the combinations constructed at the end would be _unique_
    For combinations in different subsets, they would definitely be different since they end with different numbers.  
    While for combinations in the same subsets, they could be further _attributed_ to smaller subsets, according to their postfixes.  
    Hence, they are unique as well.