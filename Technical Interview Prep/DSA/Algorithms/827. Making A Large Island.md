2025-08-29 11:47

Link: https://leetcode.com/problems/making-a-large-island/description/?envType=company&envId=tiktok&favoriteSlug=tiktok-three-months

Problem: 
You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.

Return _the size of the largest **island** in_ `grid` _after applying this operation_.

An **island** is a 4-directionally connected group of `1`s.

**Example 1:**
**Input:** grid = [[1,0],[0,1]]
**Output:** 3
**Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3.

**Example 2:**
**Input:** grid = [[1,1],[1,0]]
**Output:** 4
**Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4.

**Example 3:**
**Input:** grid = [[1,1],[1,1]]
**Output:** 4
**Explanation:** Can't change any 0 to 1, only one island with area = 4.

**Constraints:**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 500`
- `grid[i][j]` is either `0` or `1`.

Intuition:
map cell to island id ,and compute size for each island, when 0 is flipped ,compute the potential island size we could get and update result if it is larger!  connected cell has the same island_Id

Solution:
```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        island_id = [[0] * n for _ in range(n)]
        island_size = defaultdict(int)

        def bfs(sr: int, sc: int, iid: int) -> int:
            q = deque([(sr, sc)])
            island_id[sr][sc] = iid        # MARK THE START!
            size = 0
            while q:
                r, c = q.pop()
                size += 1
                for dr, dc in dirs:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < n and 0 <= nc < n:
                        if grid[nr][nc] == 1 and island_id[nr][nc] == 0:
                            island_id[nr][nc] = iid
                            q.append((nr, nc))
            return size

        # 1) Label all islands and record their sizes
        iid = 1
        for r in range(n):
            for c in range(n):
                if grid[r][c] == 1 and island_id[r][c] == 0:
                    island_size[iid] = bfs(r, c, iid)
                    iid += 1

        # Start with the largest existing island (handles the all-1s case)
        res = max(island_size.values(), default=0)

        # 2) Try flipping each 0 and compute merged size from unique neighbor ids
        for r in range(n):
            for c in range(n):
                if grid[r][c] == 0:
                    neighbors = set()
                    for dr, dc in dirs:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < n and 0 <= nc < n:
                            neighbors.add(island_id[nr][nc])  # may include 0 (water)
                    cand = 1 + sum(island_size[id_] for id_ in neighbors if id_ != 0)
                    res = max(res, cand)

        return res
```

optimized
```python
from typing import List

class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dirs = ((1,0), (-1,0), (0,1), (0,-1))

        # 1) Relabel islands in-place: 1 -> id (>=2), record sizes[id]
        sizes = [0, 0]   # sizes[id] valid for id >= 2; pad indexes 0,1
        cur_id = 2

        def dfs(sr: int, sc: int, id_: int) -> int:
            stack = [(sr, sc)]
            grid[sr][sc] = id_
            sz = 0
            while stack:
                r, c = stack.pop()
                sz += 1
                for dr, dc in dirs:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1:
                        grid[nr][nc] = id_
                        stack.append((nr, nc))
            return sz

        for r in range(n):
            for c in range(n):
                if grid[r][c] == 1:
                    sizes.append(dfs(r, c, cur_id))
                    cur_id += 1

        # If there was at least one island, best starts there; else 0.
        best = max(sizes, default=0)

        # 2) Try flipping each 0; sum unique neighbor ids (<=4) without a set
        # Helper to add size once per id (ignore id<=1 which means water/unlabeled)
        def uniq_sum4(a, b, c, d) -> int:
            total = 0
            # We only have up to 4 ids; dedupe by hand
            seen_a = a > 1
            if seen_a: total += sizes[a]

            seen_b = (b > 1) and (not seen_a or b != a)
            if seen_b: total += sizes[b]

            seen_c = (c > 1) and (not seen_a or c != a) and (not seen_b or c != b)
            if seen_c: total += sizes[c]

            seen_d = (d > 1) and (not seen_a or d != a) and (not seen_b or d != b) and (not seen_c or d != c)
            if seen_d: total += sizes[d]

            return total

        all_one = True
        for r in range(n):
            for c in range(n):
                if grid[r][c] == 0:
                    all_one = False
                    up    = grid[r-1][c] if r > 0 else 0
                    down  = grid[r+1][c] if r+1 < n else 0
                    left  = grid[r][c-1] if c > 0 else 0
                    right = grid[r][c+1] if c+1 < n else 0
                    cand = 1 + uniq_sum4(up, down, left, right)
                    if cand > best:
                        best = cand
                        if best == n * n:  # early exit: can't do better
                            return best

        # If grid was all ones, best should be n*n
        return best if not all_one else n * n
```

Tags: #dfs #dict 

RL: 

Considerations:
