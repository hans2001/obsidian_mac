2025-11-25 23:16

Link: https://leetcode.com/problems/collect-coins-in-a-tree/description/?envType=company&envId=millennium&favoriteSlug=millennium-all

Problem: 
There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.

Initially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times: 

- Collect all the coins that are at a distance of at most `2` from the current vertex, or
- Move to any adjacent vertex in the tree.

Find _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.

Note that if you pass an edge several times, you need to count it into the answer several times.

**Example 1:**
![](https://assets.leetcode.com/uploads/2023/03/01/graph-2.png)

**Input:** coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
**Output:** 2
**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.

**Example 2:**
![](https://assets.leetcode.com/uploads/2023/03/02/graph-4.png)
**Input:** coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
**Output:** 2
**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.

**Constraints:**
- `n == coins.length`
- `1 <= n <= 3 * 104`
- `0 <= coins[i] <= 1`
- `edges.length == n - 1`
- `edges[i].length == 2`
- `0 <= ai, bi < n`
- `ai != bi`
- `edges` represents a valid tree.

Intuition:
we can first remove leaf node without coin ,we sould never visit them .then consider at the starting node, we can collect distance within 2 for node with coins, we can remvoe coins and its paretn, since those node will be automatically collected, without going through the edge between them. Now we have the remaining nodes that we have to use as the starting node. 

The problem specify that we must go back to the initial vertex we start, therefore, we know that we would traverse number of edges in core tree twice! from the start to target node then come back! which is 2 * (k-1). where k is number of node in core tree! 

Solution:
```python
from collections import deque
from typing import List

class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        n = len(coins)
        if n == 1:
            return 0

        # build graph
        adj = [[] for _ in range(n)]
        deg = [0] * n
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
            deg[u] += 1
            deg[v] += 1

        # ---------- 1) prune leaves with no coins ----------
        q = deque()
        for i in range(n):
            if deg[i] == 1 and coins[i] == 0:
                q.append(i)

        removed = [False] * n

        while q:
            u = q.popleft()
            if removed[u]:
                continue
            removed[u] = True
            for v in adj[u]:
                if removed[v]:
                    continue
                deg[v] -= 1
                if deg[v] == 1 and coins[v] == 0:
                    q.append(v)

        # ---------- 2) prune two layers of leaves (distance <= 2) ----------
        # First, collect current leaves that are still alive
        q = deque(i for i in range(n) if not removed[i] and deg[i] == 1)

        # We do this *twice*: remove leaves, then their new leaves (their parents)
        for _ in range(2):
            size = len(q)
            for _ in range(size):
                u = q.popleft()
                if removed[u]:
                    continue
                removed[u] = True
                for v in adj[u]:
                    if removed[v]:
                        continue
                    deg[v] -= 1
                    if deg[v] == 1:
                        q.append(v)

        # ---------- 3) count remaining edges ----------
        remaining_edges = 0
        for u in range(n):
            if removed[u]:
                continue
            for v in adj[u]:
                if not removed[v]:
                    remaining_edges += 1

        # each edge counted twice (u->v and v->u)
        remaining_edges //= 2
        return remaining_edges * 2
```

Tags: #topological_sort #tree_math 

RL: 

Considerations:
