2025-11-25 22:32

Link: https://leetcode.com/problems/path-sum-iii/description/?envType=company&envId=millennium&favoriteSlug=millennium-all

Problem: 
Given the `root` of a binary tree and an integer `targetSum`, return _the number of paths where the sum of the values along the path equals_ `targetSum`.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

**Input:** root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
**Output:** 3
**Explanation:** The paths that sum to 8 are shown.

**Example 2:**
**Input:** root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
**Output:** 3

**Constraints:**
- The number of nodes in the tree is in the range `[0, 1000]`.
- `-109 <= Node.val <= 109`
- `-1000 <= targetSum <= 1000`

Intuition:
- curr_sum - target = 7 tells us **how many ancestor prefix sums would yield a valid path ending here** → prefix_count[7] = 0 → **no valid paths ending here**.
    
- Then we do prefix_count[15] += 1 because **prefix sum 15 must be recorded for deeper nodes**, so they can form paths beginning at this node.
    
- After finishing node 5’s subtree, we backtrack to remove 15 because **prefix_count must always describe only the current root→node path**, not paths belonging to sibling branches.

Solution:
```python
class Solution:
    rtrn = 0
    def pathSumAtNode(self, root: Optional[TreeNode], targetSum: int) -> None:
        if root.val == targetSum:
            self.rtrn += 1
        targetSum -= root.val
        if root.left:
            self.pathSumAtNode(root.left, targetSum)
        if root.right:
            self.pathSumAtNode(root.right, targetSum)
    def findAllPath(self, root, targetSum):
        self.pathSumAtNode(root, targetSum)
        if root.left:
            self.findAllPath(root.left, targetSum)
        if root.right:
            self.findAllPath(root.right, targetSum)
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        if not root:
            return 0
        self.rtrn = 0
        self.findAllPath(root, targetSum)
        return self.rtrn
```

optimized with prefix sm and hasmap
```python
from collections import defaultdict

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        prefix_count = defaultdict(int)
        prefix_count[0] = 1  # sum 0 occurs once before starting

        def dfs(node, curr_sum):
            if not node:
                return 0

            curr_sum += node.val
            # number of paths ending here with sum == targetSum
            res = prefix_count[curr_sum - targetSum]

            prefix_count[curr_sum] += 1
            res += dfs(node.left, curr_sum)
            res += dfs(node.right, curr_sum)
            prefix_count[curr_sum] -= 1  # backtrack

            return res

        return dfs(root, 0)
```

Tags: #dfs #prefix_sum  

RL: 

Considerations:
