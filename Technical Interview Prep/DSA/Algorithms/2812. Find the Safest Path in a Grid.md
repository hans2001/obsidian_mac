2025-05-22 12:55

Link: https://leetcode.com/problems/find-the-safest-path-in-a-grid/description/

Problem: 
You are given a **0-indexed** 2D matrix `grid` of size `n x n`, where `(r, c)`represents:

- A cell containing a thief if `grid[r][c] = 1`
- An empty cell if `grid[r][c] = 0`

You are initially positioned at cell `(0, 0)`. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.

The **safeness factor** of a path on the grid is defined as the **minimum**manhattan distance from any cell in the path to any thief in the grid.

Return _the **maximum safeness factor** of all paths leading to cell_ `(n - 1, n - 1)`_._

An **adjacent** cell of cell `(r, c)`, is one of the cells `(r, c + 1)`, `(r, c - 1)`, `(r + 1, c)` and `(r - 1, c)` if it exists.

The **Manhattan distance** between two cells `(a, b)` and `(x, y)` is equal to `|a - x| + |b - y|`, where `|val|` denotes the absolute value of val.

Intuition:
first we evaluate safeness for all cell and store the weight in a n * n matrix. then as we do Dijkstra with max heap, we try to use the cell with largest safety level, until we reach the destination, if that cannot be done, we naturally have to compromise to use cell that is less safe, and we update the safeness so far for the current path. finally when we reach the destination we return the safeness so far, which is naturally the maximum safety of the optimal path

Solution:
Multi-Source bfs(building the safe matrix) with Dijkstra
```python
class Solution:
    dir = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:
        n = len(grid)

        multi_source_queue = deque()
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    # Push thief coordinates to the queue
                    multi_source_queue.append((i, j))
                    grid[i][j] = 0
                else:
                    grid[i][j] = -1

        while multi_source_queue:
            size = len(multi_source_queue)
            while size > 0:
                curr = multi_source_queue.popleft()
                # Check neighboring cells
                for d in self.dir:
                    di, dj = curr[0] + d[0], curr[1] + d[1]
                    val = grid[curr[0]][curr[1]]
                    if self.isValidCell(grid, di, dj) and grid[di][dj] == -1:
                        # Update safeness factor and push to the queue
                        grid[di][dj] = val + 1
                        multi_source_queue.append((di, dj))
                size -= 1
        
        pq = [[-grid[0][0], 0, 0]] # [maximum_safeness_till_now, x-coordinate, y-coordinate]
        grid[0][0] = -1 # Mark the source cell as visited

        while pq:
            safeness, i, j = heapq.heappop(pq)
            
            if i == n - 1 and j == n - 1:
                return -safeness
            for d in self.dir:
                di, dj = i + d[0], j + d[1]
                if self.isValidCell(grid, di, dj) and grid[di][dj] != -1:
                    heapq.heappush(pq, [-min(-safeness, grid[di][dj]), di, dj])
                    grid[di][dj] = -1
        return -1
    
    def isValidCell(self, grid, i, j) -> bool:
        n = len(grid)
        return 0 <= i < n and 0 <= j < n
```

Complexity:
Time: 
O(n^2 (log n))
building the safety matrix takes O(n^2) time, where we have n ^2 number of cells
to find the optimal path, in worst case, we might have to visit every cell if every cell's safety is the same O(n^2) here, and in each iteration, we perform 2 O(log n) operation with the heap 

Space:
O(n^2) for the safety matrix and potentially the queue 

Tags: #multi_source_bfs  #dijkstra #bfs  

RL: 

Considerations:
