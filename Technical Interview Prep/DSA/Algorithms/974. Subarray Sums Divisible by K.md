2025-10-18 10:52

Link: https://chatgpt.com/c/68f3a3ba-ba90-8323-95a4-d672017e07d0

Problem: 
Given an integer array `nums` and an integer `k`, return _the number of non-empty **subarrays** that have a sum divisible by_ `k`.

A **subarray** is a **contiguous** part of an array.

**Example 1:**
**Input:** nums = [4,5,0,-2,-3,1], k = 5
**Output:** 7
**Explanation:** There are 7 subarrays with a sum divisible by k = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

**Example 2:**
**Input:** nums = [5], k = 9
**Output:** 0

**Constraints:**
- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `2 <= k <= 104`

Intuition:
We don’t care which `i` — only **how many** earlier `i`s shared the same remainder.  
Every time the remainder repeats, we instantly count all new `(i, j)` pairs it creates.

Yes — we **don’t need to track `i` explicitly** at all.  
We only need to know **how many prefix sums so far** had the _same remainder_ as the current prefix sum.

Because:
> If `pref[j] % k == pref[i] % k`, then the subarray `(i, j]` has a sum divisible by `k`

So when you’re at index `j`, the number of valid `i`s is just the **count of earlier prefixes with that same remainder**.

Say we’ve seen these prefix remainders so far for `k = 5`:
`[0, 4, 4, 2, 4]`
Now suppose we’re at a new remainder `r = 4`.  
Earlier, `4` appeared 3 times — that means **3 possible subarrays** end at this index (`(i=1, j)`, `(i=2, j)`, `(i=4, j)`).

That’s why we do:
`ans += count[r] count[r] += 1`
- `ans += count[r]`: add all subarrays ending here.
- `count[r] += 1`: record this prefix for future subarrays.

Solution:
prefix sum  + O(n) solution
```python
from collections import defaultdict

class Solution(object):
    def subarraysDivByK(self, nums, k):
        count = defaultdict(int)
        count[0] = 1                # empty prefix
        ps = ans = 0
        for x in nums:
            ps += x
            r = (ps % k + k) % k    # handle negatives safely
            ans += count[r]         # all prior i with same remainder
            count[r] += 1           # this prefix becomes a future i
        return ans
```

Tags: #prefix_sum #remainder #modulo #hash_map 

RL: 

Considerations:
