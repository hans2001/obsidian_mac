2025-04-23 11:27

Link: https://leetcode.com/problems/evaluate-division/description/?envType=company&envId=bloomberg&favoriteSlug=bloomberg-thirty-days

Problem: 
You are given an array of variable pairs `equations` and an array of real numbers `values`, where `equations[i] = [Ai, Bi]` and `values[i]` represent the equation `Ai / Bi = values[i]`. Each `Ai` or `Bi` is a string that represents a single variable.

You are also given some `queries`, where `queries[j] = [Cj, Dj]` represents the `jth`query where you must find the answer for `Cj / Dj = ?`.

Return _the answers to all queries_. If a single answer cannot be determined, return `-1.0`.

**Note:** The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

**Note:** The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.

**Example 1:**
**Input:** equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
**Output:** [6.00000,0.50000,-1.00000,1.00000,-1.00000]
**Explanation:** 
Given: _a / b = 2.0_, _b / c = 3.0_
queries are: _a / c = ?_, _b / a = ?_, _a / e = ?_, _a / a = ?_, _x / x = ?_ 
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined => -1.0

**Example 2:**
**Input:** equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
**Output:** [3.75000,0.40000,5.00000,0.20000]

**Example 3:**
**Input:** equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
**Output:** [0.50000,2.00000,-1.00000,-1.00000]

Intuition:
a /c == a / b = 2.0, _b / c = 3.0_ == a / b * b / c
so we can construct a path form a to c by multiplying the weight along the way
handle base case queries where source == target or either source or target is not in the dict! 
then we use bfs to find if a valid path exist, where we can compute the result of the query by taking the product of weights! if valid path not found, the query cannot be computed, we return -1!

Solution:
```python
from collections import defaultdict ,deque
class Solution:
	def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
		res = [ ]
		d= defaultdict ( list )
		for i in range ( len ( equations )) :
			source ,target = equations[ i ]
			d[ source ] .append ( (target , values[ i ]))
			d[ target ] .append ( (source, 1 / values[ i ]))
		
		# resolve queries
		for src, dst in queries :
			# base case handling!
			if src not in d or dst not in d:
				res.append ( -1.0 )
				continue
			
			if src == dst:
				res.append ( 1.0 )
				continue
				
			vis = set( )
			q = deque ([(src, 1.0 )])
			found = False
			
			# search for a valid path!
			while q and not found:
				node, weight =q.popleft( )
				if node == dst:
					res.append (weight)
					found = True
					break
				# set node as viisted!
				vis.add( node )
				for ne ,ne_weight in d[node] :
					if ne not in vis:
						q.append( (ne , weight * ne_weight ))
			
			if not found :
				res.append ( -1.0 )
				
		return res
```

Complexity:
## Time Complexity
1. **Building the Graph**:
    - For each equation, we add two edges to our graph
    - Time: O(E) where E is the number of equations
2. **Processing Queries**:
    - For each query, in the worst case, we perform a BFS that might visit all nodes and edges
    - Each BFS takes O(V + E) time where V is the number of variables and E is the number of edges
    - We process Q queries
    - Time: O(Q * (V + E))
3. **Overall Time Complexity**: O(E + Q * (V + E))
    - Since E is at most V², we can also express this as O(E + Q * V²)
    - In the worst case, if the graph is dense, this becomes O(V² + Q * V²) = O((Q+1) * V²)
    - If Q is much larger than 1, we can simplify to O(Q * V²)

## Space Complexity
1. **Graph Storage**:
    - In the worst case, we have edges between all pairs of nodes
    - Space: O(V + E) = O(V + V²) = O(V²)
2. **BFS Queue**:
    - In the worst case, all nodes could be in the queue
    - Space: O(V)
3. **Visited Set**:
    - In the worst case, we visit all nodes
    - Space: O(V)
4. **Results Array**:
    - We store one result for each query
    - Space: O(Q)
5. **Overall Space Complexity**: O(V² + V + V + Q) = O(V² + Q)
    - If V² dominates Q, then it's O(V²)
    - If Q dominates V², then it's O(Q)
    - In general, we can say the space complexity is O(max(V², Q))

Tags: #bfs #directed_acyclic_graph

RL: 

Considerations:
