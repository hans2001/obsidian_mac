2025-12-10 16:14

Link: https://leetcode.com/problems/alternating-groups-ii/

Problem: 
There is a circle of red and blue tiles. You are given an array of integers `colors` and an integer `k`. The color of tile `i` is represented by `colors[i]`:

- `colors[i] == 0` means that tile `i` is **red**.
- `colors[i] == 1` means that tile `i` is **blue**.

An **alternating** group is every `k` contiguous tiles in the circle with **alternating** colors (each tile in the group except the first and last one has a different color from its **left** and **right** tiles).

Return the number of **alternating** groups.

**Note** that since `colors` represents a **circle**, the **first** and the **last** tiles are considered to be next to each other.

**Example 1:**
**Input:** colors = [0,1,0,1,0], k = 3
**Output:** 3
**Explanation:**

**![](https://assets.leetcode.com/uploads/2024/06/19/screenshot-2024-05-28-183519.png)**

Alternating groups:

![](https://assets.leetcode.com/uploads/2024/05/28/screenshot-2024-05-28-182448.png)![](https://assets.leetcode.com/uploads/2024/05/28/screenshot-2024-05-28-182844.png)![](https://assets.leetcode.com/uploads/2024/05/28/screenshot-2024-05-28-183057.png)

**Example 2:**
**Input:** colors = [0,1,0,0,1,0,1], k = 6
**Output:** 2
**Explanation:**

**![](https://assets.leetcode.com/uploads/2024/06/19/screenshot-2024-05-28-183907.png)**

Alternating groups:

![](https://assets.leetcode.com/uploads/2024/06/19/screenshot-2024-05-28-184128.png)![](https://assets.leetcode.com/uploads/2024/06/19/screenshot-2024-05-28-184240.png)

**Example 3:**
**Input:** colors = [1,1,0,1], k = 4
**Output:** 0
**Explanation:**

![](https://assets.leetcode.com/uploads/2024/06/19/screenshot-2024-05-28-184516.png)

**Constraints:**

- `3 <= colors.length <= 105`
- `0 <= colors[i] <= 1`
- `3 <= k <= colors.length`

Intuition:
we missed the idea of pre-computation. so our solution TLE
assume k should be less than 2 * n where n is the length of colors
we can initialize the 2* n arr that help us precompute the longest alternating group so far at index i, since we treat each position as a starting point ,from 0 to n-1 ( in 0 based index). therefore we can compute the result by directly checking if alt[i] >= k, where alt[i] would be = 1 + alt[i] if colors[i] != colors[i+1], otherwise, alt[i] stays at 1 ,since the connection to next block is broken (not alternating!)

build an optimization framework where i should approach when TLE

Solution:
```python
class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        """
        Count how many starting positions form a length-k alternating group on a circular array.

        We handle circularity by doubling the array: ext = colors + colors.
        Then we compute alt[i], the length of the alternating run starting at ext[i],
        by building it right-to-left so we can reuse alt[i+1].

        An index j in the original array is valid iff alt[j] >= k.
        """
        n = len(colors)
        ext = colors + colors
        m = len(ext)

        # alt[i] = length of the alternating streak starting at index i
        alt = [1] * m
        for i in range(m - 2, -1, -1):
            if ext[i] != ext[i + 1]:
                alt[i] = alt[i + 1] + 1

        # Count valid starting positions in the original array
        res = 0
        for j in range(n):
            if alt[j] >= k:
                res += 1

        return res
```

Tags: #precomputation #prefix_sum 

RL: 

Considerations:
