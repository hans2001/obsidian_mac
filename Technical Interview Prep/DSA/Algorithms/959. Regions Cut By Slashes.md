2025-08-26 18:44

Link: https://leetcode.com/problems/regions-cut-by-slashes/description/?envType=company&envId=tiktok&favoriteSlug=tiktok-three-months

Problem: 
An `n x n` grid is composed of `1 x 1` squares where each `1 x 1` square consists of a `'/'`, `'\'`, or blank space `' '`. These characters divide the square into contiguous regions.

Given the grid `grid` represented as a string array, return _the number of regions_.

Note that backslash characters are escaped, so a `'\'` is represented as `'\\'`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/15/1.png)

**Input:** grid = [" /","/ "]
**Output:** 2

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/15/2.png)

**Input:** grid = [" /","  "]
**Output:** 1

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/15/4.png)

**Input:** grid = ["/\\","\\/"]
**Output:** 5
**Explanation:** Recall that because \ characters are escaped, "\\/" refers to \/, and "/\\" refers to /\.

**Constraints:**
- `n == grid.length == grid[i].length`
- `1 <= n <= 30`
- `grid[i][j]` is either `'/'`, `'\'`, or `' '`.

Intuition:
map this problem to a number of unique land problem, first we model the grid as a m * m grid, where m is 3 * n. then we use either the forward slash or backward slash to establish obstacles in the new grid. then in new grid we could just run the flood fill problem to count the number of unique islands! 

triangle with DSU:
initially we set all triangles as isolated, then we use the signal to union them together. finally we count the number of unique roots in DSU ,which is the result

Solution:
expanded grid
```python
from typing import List
from collections import deque

def regionsBySlashes_3x3(grid: List[str]) -> int:
    n = len(grid)
    m = 3 * n
    # 1 = blocked (slash pixels), 0 = empty
    pix = [[0]*m for _ in range(m)]

    # draw each cell into a 3x3 block
    for r in range(n):
        for c in range(n):
            ch = grid[r][c]
            R, C = 3*r, 3*c
            if ch == '/':
                pix[R+0][C+2] = 1
                pix[R+1][C+1] = 1
                pix[R+2][C+0] = 1
            elif ch == '\\':
                pix[R+0][C+0] = 1
                pix[R+1][C+1] = 1
                pix[R+2][C+2] = 1
            # spaces leave all 9 pixels empty

    # BFS over empty pixels to count connected components
    seen = [[False]*m for _ in range(m)]
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    regions = 0

    for i in range(m):
        for j in range(m):
            if pix[i][j] == 0 and not seen[i][j]:
                regions += 1
                q = deque([(i,j)])
                seen[i][j] = True
                while q:
                    x, y = q.popleft()
                    for dx, dy in dirs:
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < m and 0 <= ny < m:
                            if pix[nx][ny] == 0 and not seen[nx][ny]:
                                seen[nx][ny] = True
                                q.append((nx,ny))
    return regions
```
time: O(n^2) 
iterating original grid to build the new grid : O(n^2)
worst case traversing  every cell in the new grid taking O(m*m) time, 
so overall complexity domainted by n* n 

DSU with tranigles
```python
from typing import List

class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x: int) -> int:
        # path compression
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, a: int, b: int) -> bool:
        # union by rank; returns True if merged, False if already connected
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.rank[ra] < self.rank[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        if self.rank[ra] == self.rank[rb]:
            self.rank[ra] += 1
        return True

def regionsBySlashes(grid: List[str]) -> int:
    """
    Triangle method:
      - Each cell is split into 4 triangles: 0=top, 1=right, 2=bottom, 3=left
      - Inside-cell unions depend on '/', '\\', or ' '.
      - Between-cell unions stitch neighbors: bottom↔top, right↔left.
      - Result = number of DSU components among all triangles.
    """
    n = len(grid)
    if n == 0:
        return 0

    # total triangles
    total = n * n * 4
    dsu = DSU(total)

    # global triangle id
    def idx(i: int, j: int, part: int) -> int:
        # (row-major cell id) * 4 + triangleNum
        return (i * n + j) * 4 + part

    for i in range(n):
        for j in range(n):
            ch = grid[i][j]

            # --- inside the cell ---
            # mapping: 0=top, 1=right, 2=bottom, 3=left
            if ch == ' ':
                # connect all four
                dsu.union(idx(i, j, 0), idx(i, j, 1))
                dsu.union(idx(i, j, 1), idx(i, j, 2))
                dsu.union(idx(i, j, 2), idx(i, j, 3))
            elif ch == '/':
                # connect (top,left) and (right,bottom)
                dsu.union(idx(i, j, 0), idx(i, j, 3))
                dsu.union(idx(i, j, 1), idx(i, j, 2))
            else:  # ch == '\\'
                # connect (top,right) and (bottom,left)
                dsu.union(idx(i, j, 0), idx(i, j, 1))
                dsu.union(idx(i, j, 2), idx(i, j, 3))

            # --- connect to neighbors ---
            # down neighbor: our bottom (2) to below's top (0)
            if i + 1 < n:
                dsu.union(idx(i, j, 2), idx(i + 1, j, 0))
            # right neighbor: our right (1) to right cell's left (3)
            if j + 1 < n:
                dsu.union(idx(i, j, 1), idx(i, j + 1, 3))

    # count distinct components (unique roots)
    roots = set(dsu.find(x) for x in range(total))
    return len(roots)
```
Tags: #bfs #grid 

RL: 

Considerations:
