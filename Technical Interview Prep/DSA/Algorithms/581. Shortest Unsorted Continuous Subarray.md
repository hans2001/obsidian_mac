2025-10-03 20:28

Link: https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description/

Problem: 
Given an integer array `nums`, you need to find one **continuous subarray** such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.

Return _the shortest such subarray and output its length_.

**Example 1:**
**Input:** nums = [2,6,4,8,10,9,15]
**Output:** 5
**Explanation:** You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.

**Example 2:**
**Input:** nums = [1,2,3,4]
**Output:** 0

**Example 3:**
**Input:** nums = [1]
**Output:** 0

**Constraints:**
- `1 <= nums.length <= 104`
- `-105 <= nums[i] <= 105`

Intuition:
to maintain a sorted seq at the end, we must include every violation, so we perform 2 sweep to identify the left and boundary for the arr to be fix. we should stretch as far as possible since if we do not do that, there would always be an element that violate the sorted seq, so we have to include it in the window. as we do either form left to right or vice versa, we keep the locally max or min value ,so when we found ele that violate the locally optimized variable for the sorted seq, we knwo that position is a violating position 

Solution:
```python
def findUnsortedSubarray(nums):
    n = len(nums)
    left, right = -1, -2  # ensures 0 if already sorted
    max_seen, min_seen = float('-inf'), float('inf')

    for i in range(n):
        max_seen = max(max_seen, nums[i])
        if nums[i] < max_seen:
            right = i

    for j in range(n - 1, -1, -1):
        min_seen = min(min_seen, nums[j])
        if nums[j] > min_seen:
            left = j

    return right - left + 1
```

Tags: #greedy #2_pointer 

RL: 

Considerations:
