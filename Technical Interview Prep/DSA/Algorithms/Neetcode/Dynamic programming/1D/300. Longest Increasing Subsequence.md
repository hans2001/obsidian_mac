2025-02-11 19:55

Link: https://neetcode.io/problems/longest-increasing-subsequence

Problem: 
Given an integer arrayÂ `nums`, return theÂ _length_Â of the longest strictlyÂ _increasing_Â subsequence.

AÂ **subsequence**Â is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.
- For example,Â `"cat"`Â is a subsequence ofÂ `"crabt"`.

Motivation:
Top-down approach:
- **When Including J**:
    - In this case, we updateÂ `j`Â by making the recursive callÂ `dfs(i + 1, i)`.
    - Here,Â `i`Â becomes the newÂ `j`Â becauseÂ `nums[i]`Â is now the last element in the subsequence.
- **When Not Including**:
    - If we choose not to includeÂ `nums[i]`, we simply callÂ `dfs(i + 1, j)`, leavingÂ `j`Â unchanged since the last included element remains the same.

if condition satisfied, we can include nums[j] into the sequence, and take maximum LIS returned by both ways! 

Botton-up:
build the memoized array from the end. use 2 iterative for loop, with pointer i indicating the starting number in the sequence, and pointer j indicating the number to be included in the sequence(if condition is met). 1 + LIS[j] means we increment one to the longest subsequence starting from index j, which allow us to inherit the computed result, and +1 mean we include nums[i] as the starting number! 


BS + greedy
ðŸ‘‰ The trick:Â **we donâ€™t care about the actual subsequence, just its length.**

Why? Because to build aÂ _long_Â subsequence, the only thing that matters at each step is:  
â€œwhatâ€™s the smallest possible ending number if I build an increasing subsequence of lengthÂ `k`?â€
Smaller tail =Â **more chances**Â to extend it later.

1. **Monotonicity ofÂ `tails`:**
    - `tails`Â is always sorted.
    - Length ofÂ `tails`Â only increases when weâ€™ve found a longer subsequence.
        
2. **Safe replacement:**
    - Replacing a tail never reduces the maximum subsequence length achievable.
    - It only improves (or maintains) our chances, because a smaller tail is strictly â€œbetterâ€ for potential extension.
        
The LIS problem is aboutÂ **subsequences**, which mustÂ **preserve the original order**Â of elements.

Thus, by the end:
- `len(tails)`Â = length of the LIS.
- We donâ€™t lose LIS candidates because we always keep theÂ **best (smallest tail) representatives**Â at each length.


Solution:
Binary search:
```python
from bisect import bisect_left
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        dp.append(nums[0])

        LIS = 1
        for i in range(1, len(nums)):
            if dp[-1] < nums[i]: 
                dp.append(nums[i])
                LIS += 1
                continue

            idx = bisect_left(dp, nums[i])
            dp[idx] = nums[i] 

        return LIS
```
O(n log n) / O(n)

DP (bottom-up):
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        LIS = [1] * len(nums)

        for i in range(len(nums) - 1, -1, -1):
            for j in range(i + 1, len(nums)):
                if nums[i] < nums[j]:
                    LIS[i] = max(LIS[i], 1 + LIS[j])
        return max(LIS)
```
O(n^2) / O(n^2)

DP (top-down):
```python
class Solution:
    def lengthOfLIS(self, nums):
        n = len(nums)
        memo = [[-1] * (n + 1) for _ in range(n)]  

        def dfs(i, j):
            if i == n:
                return 0
            if memo[i][j + 1] != -1:
                return memo[i][j + 1]

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            memo[i][j + 1] = LIS
            return LIS

        return dfs(0, -1)
```
Â O(n^2) / O(n^2)
Â 
Tags: #1d_dp #iterative #array 

RL: 