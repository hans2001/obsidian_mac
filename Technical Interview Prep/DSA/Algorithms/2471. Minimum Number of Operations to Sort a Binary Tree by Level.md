2025-12-21 13:13

Link: https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/

Problem: 
You are given the `root` of a binary tree with **unique values**.

In one operation, you can choose any two nodes **at the same level** and swap their values.

Return _the minimum number of operations needed to make the values at each level sorted in a **strictly increasing order**_.

The **level** of a node is the number of edges along the path between it and the root node_._

**Example 1:**
![](https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png)

**Input:** root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
**Output:** 3
**Explanation:**
- Swap 4 and 3. The 2nd level becomes [3,4].
- Swap 7 and 5. The 3rd level becomes [5,6,8,7].
- Swap 8 and 7. The 3rd level becomes [5,6,7,8].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.

**Example 2:**
![](https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png)

**Input:** root = [1,3,2,7,6,5,4]
**Output:** 3
**Explanation:**
- Swap 3 and 2. The 2nd level becomes [2,3].
- Swap 7 and 4. The 3rd level becomes [4,6,5,7].
- Swap 6 and 5. The 3rd level becomes [4,5,6,7].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.

**Example 3:**
![](https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png)

**Input:** root = [1,2,3,4,5,6]
**Output:** 0
**Explanation:** Each level is already sorted in increasing order so return 0.

**Constraints:**
- The number of nodes in the tree is in the range `[1, 105]`.
- `1 <= Node.val <= 105`
- All the values of the tree are **unique**.

Intuition:
> For each level, we only care about reordering the node values, not the tree structure.

> Sorting the values induces a permutation from current indices to their target indices in the sorted order.

> This permutation can be decomposed into disjoint cycles, where each cycle represents a group of values that must be rotated among themselves.

> A cycle of length k requires exactly k - 1 swaps to place all values in their correct positions.

> Therefore, the minimum number of swaps needed for a level is the sum of (\text{cycle length} - 1) over all cycles.

Solution:
```python
from collections import deque
from typing import Optional

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        def count_swaps(arr):
            n = len(arr)
            pairs = sorted((v, i) for i, v in enumerate(arr))
            visited = [False] * n
            swaps = 0

            for i in range(n):
                if visited[i] or pairs[i][1] == i:
                    continue

                cycle_len = 0
                j = i
                while not visited[j]:
                    visited[j] = True
                    j = pairs[j][1]
                    cycle_len += 1

                swaps += cycle_len - 1

            return swaps

        q = deque([root])
        res = 0

        while q:
            level_size = len(q)
            level_vals = []

            for _ in range(level_size):
                node = q.popleft()
                level_vals.append(node.val)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

            res += count_swaps(level_vals)

        return res
```

Time: O(klogk)
k = number of nodes at a level
Summed over all levels → O(n log n) worst case


Tags: #binary_tree #min_swaps #cycle_detection 

RL: 

Considerations:
