2025-10-22 20:19

Link: https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/description/

Problem: 
You are given the `root` of a **binary tree** with `n` nodes. Each node is uniquely assigned a value from `1` to `n`. You are also given an integer `startValue` representing the value of the start node `s`, and a different integer `destValue` representing the value of the destination node `t`.

Find the **shortest path** starting from node `s` and ending at node `t`. Generate step-by-step directions of such path as a string consisting of only the **uppercase** letters `'L'`, `'R'`, and `'U'`. Each letter indicates a specific direction:

- `'L'` means to go from a node to its **left child** node.
- `'R'` means to go from a node to its **right child** node.
- `'U'` means to go from a node to its **parent** node.

Return _the step-by-step directions of the **shortest path** from node_ `s` _to node_ `t`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/11/15/eg1.png)

**Input:** root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
**Output:** "UURL"
**Explanation:** The shortest path is: 3 → 1 → 5 → 2 → 6.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/11/15/eg2.png)

**Input:** root = [2,1], startValue = 2, destValue = 1
**Output:** "L"
**Explanation:** The shortest path is: 2 → 1.

**Constraints:**

- The number of nodes in the tree is `n`.
- `2 <= n <= 105`
- `1 <= Node.val <= n`
- All the values in the tree are **unique**.
- `1 <= startValue, destValue <= n`
- `startValue != destValue`

Intuition:
build path form root to both start and dest firs , then remove prefix form both path( idea of LCA ) , then reverse path form root to start as U , then aggregate 2 of them to get the answer! 

Solution:
```python
class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        def build_path(node: Optional[TreeNode], target: int, path: list[str]) -> bool:
            if not node:
                return False
            if node.val == target:
                return True
            path.append('L')
            if build_path(node.left, target, path):
                return True
            path.pop()
            path.append('R')
            if build_path(node.right, target, path):
                return True
            path.pop()
            return False

        start_path, end_path = [], []
        found_start = build_path(root, startValue, start_path)
        found_dest  = build_path(root, destValue, end_path)
        if not (found_start and found_dest):
            return ""  # or raise if the problem guarantees both exist

        i = 0
        while i < len(start_path) and i < len(end_path) and start_path[i] == end_path[i]:
            i += 1

        up = 'U' * (len(start_path) - i)
        down = ''.join(end_path[i:])
        return up + down

```

Tags: #LCA #dfs  #backtracking 

RL: 

Considerations:
