2025-04-22 14:07

Link: https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/?envType=company&envId=bloomberg&favoriteSlug=bloomberg-thirty-days

Problem: 
Given the `root` of a binary tree, flatten the tree into a "linked list":

- The "linked list" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.
- The "linked list" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

**Input:** root = [1,2,5,3,4,null,6]
**Output:** [1,null,2,null,3,null,4,null,5,null,6]

Intuition:
recursively flatten node! base case: if node is null or if node is leaf node! 
if node has left and right child!, we attach the right node to left tail, and set right node as the left starting node, then set node's left to be nothing! we perform this at nested node first, before coming back to the tree's root
This ensures we can handle the tree's transformation in a bottom-up manner. By flattening the deeper nodes first, we ensure that when we return to the parent nodes, their children are already properly flattened.

Key insights: 
- First recursively flatten both subtrees
- Connect the flattened left subtree to the node
- Find the tail of this left subtree
- Connect this tail to the flattened right subtree
- Remove the left pointer

Solution:
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def flattenTree(self, node: TreeNode) -> TreeNode:
        # Handle the null scenario
        if not node:
            return None

        # For a leaf node, we simply return the
        # node as is.
        if not node.left and not node.right:
            return node

        # Recursively flatten the left subtree
        leftTail = self.flattenTree(node.left)

        # Recursively flatten the right subtree
        rightTail = self.flattenTree(node.right)

        # If there was a left subtree, we shuffle the connections
        # around so that there is nothing on the left side
        # anymore.
        # leftTail is connect to previous right node, then current right node is set to the left node, and current node's left should be None
        if leftTail:
            leftTail.right = node.right
            node.right = node.left
            node.left = None

        # We need to return the "rightmost" node after we are
        # done wiring the new connections.
        return rightTail if rightTail else leftTail

    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.flattenTree(root)
```
time / space complexity: O(N) / O(N)
process each node in the tree exactly once!
worse case if the tree is left-skewed, the recursion call stack can be as long as O(n)

Tags: #tree #linked_list #recursion #binary_tree 

RL: 

Considerations:
