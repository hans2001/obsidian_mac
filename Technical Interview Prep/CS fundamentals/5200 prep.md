# Normal form identification
- Check for **atomic values** → 1NF
- Check for **partial dependencies on composite keys** → 2NF
- Check for **transitive dependencies** → 3NF
- Final schema should be in **3NF** for your exam’s requirement.

# Functional dependencies
### Types
- **Full FD:** B depends fully on A (not on part of A)
- **Partial FD:** B depends on part of a composite key
- **Transitive FD:** A → B and B → C implies A → C

- If two rows have the same `X`, they must have the same `Y`.
- **Determinant:** the attribute(s) on the left side (X)
- **Dependent:** the attribute(s) on the right side (Y)

A **functional dependency** (FD) exists when the value of one attribute (or set of attributes) **uniquely determines** the value of another attribute.

# Definition and the ability to identify update anomalies  
- **Insertion anomaly:** Can’t add data because other data is missing.  
    _Example:_ Can’t add a new course unless a student enrolls in it.
 

- **Deletion anomaly:** Deleting data removes unintended information.  
    _Example:_ Deleting a student removes the only record of a course.
loss of information( data not directly in this table, but all its dependecies is removed )
    
- **Update anomaly:** Inconsistent data after an update. （identify this one ) 
    _Example:_ Student address must be updated in multiple rows.
so if multiple row repeat same data ,a new tuple might have different values, but mean the same thing, that is when we have a update anomaly

# Definition and the ability to classify tables as 1st, 2nd, 3rd normal form
**Goal:** Eliminate redundancy and anomalies

| Normal Form | Rule                                                                     | How to Fix                               |
| ----------- | ------------------------------------------------------------------------ | ---------------------------------------- |
| **1NF**     | No repeating groups; each cell holds atomic (single) values              | Split multivalued columns                |
| **2NF**     | In 1NF + no partial dependencies (non-key depends on part of key)        | Separate tables for partial dependencies |
| **3NF**     | In 2NF + no transitive dependencies (non-key depends on another non-key) | Remove derived/non-key dependencies      |

| Type                      | Involves                                                         | Example                                                                  | Meaning                                     |
| ------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------- |
| **Partial dependency**    | A **non-key** attribute depends on _part_ of a **composite key** | (StudentID, CourseID) → Grade, but StudentName depends only on StudentID | Problem: dependency on only part of key     |
| **Transitive dependency** | A **non-key** attribute depends on another **non-key attribute** | StudentID → DeptID → DeptName                                            | Problem: dependency through another non-key |
-  **1NF:** Make sure data is atomic. (No lists or nested values)
- **2NF:** Make sure each non-key depends on the _whole_ key. (Fix partial dependencies)
- **3NF:** Make sure no non-key depends on _another_ non-key. (Fix transitive dependencies)

# Know the definitions for conceptual, logical, and physical database design  
- **Conceptual Design (ERD)**
    - High-level entities, attributes, and relationships.
    - Represented in **ER diagrams (Crow’s Foot notation)**.
- **Logical Design**
    - Converts ERD to relational schema.
    - Defines primary keys, foreign keys, data types, and constraints.
- **Physical Design**
    - Implements schema in SQL, focusing on performance and storage (indexes, partitions).

#  Be familiar with the terms associated with the relational data model. 
- **Relation:** A table
- **Tuple:** A row
- **Attribute:** A column
- **Primary Key (PK):** Unique identifier
- **Foreign Key (FK):** Links tables
- **Domain constraint:** Allowed values for an attribute
- **Entity integrity:** No nulls in PK
- **Referential integrity:** FK must match PK or be null

# Be able to interpret a logical design represented in crow’s foot notation.
Used in ERDs to show relationships:
- **One-to-One (1:1):** One line each side
- **One-to-Many (1:M):** Crow’s foot on “many” side
- **Many-to-Many (M:N):** Crow’s foot both sides (usually resolved via junction table)
    
**Example:**
- `Student (1) ───< Enrolls >─── (M) Course`

# Crow's foot notation
![[Screenshot 2025-10-14 at 2.39.01 PM.png]]


Decomposition
![[Screenshot 2025-10-14 at 3.05.20 PM.png]]
Lossless join property: 
join table together to generate he original table (information is not loss)

Dep preservation prop: 
func dep relation is not lost for new table


## Lossless join
![[Screenshot 2025-10-14 at 3.06.54 PM.png]]

## Summary - Schema Refinement
![[Screenshot 2025-10-14 at 3.07.40 PM.png]]

redundancy is only allowed for foreign key ( for 3NF form )

