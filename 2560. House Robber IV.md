2025-12-08 20:55

Link: https://leetcode.com/problems/house-robber-iv/description/

Problem: 
There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.

The **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.

You are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.

You are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.

Return _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.

**Example 1:**
**Input:** nums = [2,3,5,9], k = 2
**Output:** 5
**Explanation:** 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.

**Example 2:**
**Input:** nums = [2,7,9,3,1], k = 2
**Output:** 2
**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.

**Constraints:**
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= (nums.length + 1)/2`

Intuition:
assume we have to take all money fro m a single house, and we have to rob k house. we want to know the min value of the house with largest vlaue fgorm a valid combination( mini-max). 
brute force need us to compute each combo and then take min of all the max value form each combo. this would take exponential time. 
binary search can produce O(nlogM) solution ,where n is length of input and M is bounded by the range of the robber capacity( max (nums) )
for each cap ,we check if robber can build a valid combination by checking if he could steal k number of house! we can use greedy here, since delaying robbing a house would produce no benefit, and no road block ,so greedy is mathematically correct here

the monotonicity is built when we know that when cap is larger, the robber can rob more house , higher change to rob k number of house at least. if cap is smaller, he might not be able to select k non adjacent house! 

that is why we can bs on the target and use can_rob function to determine if we havea valid combination

Solution:
```python
from collections import defaultdict
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        n = len(nums)

        def can_rob(cap):
            i = 0
            cnt = 0

            while i < n:
                if nums[i] <= cap:
                    cnt += 1
                    i += 2
                    continue
                i += 1

            return cnt >= k

        l, r = min(nums), max(nums)
        res = l

        while l <= r:
            md = (l + r) // 2
            if can_rob(md):
                res = md
                r = md - 1
            else:
                l = md + 1

        return res
```

Tags: #binary_search 

RL: 

Considerations:
