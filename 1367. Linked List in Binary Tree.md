**2025**-12-21 17:58

Link: https://leetcode.com/problems/linked-list-in-binary-tree/description/

Problem: 
Given a binary tree `root` and a linked list with `head` as the first node. 

Return True if all the elements in the linked list starting from the `head` correspond to some _downward path_ connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

**Example 1:**
**![](https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png)**

**Input:** head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
**Output:** true
**Explanation:** Nodes in blue form a subpath in the binary Tree.  

**Example 2:**
**![](https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png)**
**Input:** head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
**Output:** true

**Example 3:**
**Input:** head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
**Output:** false
**Explanation:** There is no path in the binary tree that contains all the elements of the linked list from `head`.

**Constraints:**
- The number of nodes in the tree will be in the range `[1, 2500]`.
- The number of nodes in the list will be in the range `[1, 100]`.
- `1 <= Node.val <= 100` for each node in the linked list and binary tree.

Intuition:
we found out that concerns can actually be separated.  u always concerned about whether the starting pointer might be at subtree, so u want to proceed the root node no matter what happen, but that makes things clumsy. to better this, we can have a sub dfs function that handle by considering if this node is actually the starting pointer, and let the outer dfs function to handle if future node can be starting pointe . so for the helper function we can focusing on prune path that is not valid, without proceeding unmatched treeNode, and return True if and only if that node is actually the correct starting point for the subpath! 

Solution:
```python
class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        def match(t: Optional[TreeNode], l: Optional[ListNode]) -> bool:
            if not l:
                return True
            if not t:
                return False
            if t.val != l.val:
                return False
            return match(t.left, l.next) or match(t.right, l.next)

        def search(t: Optional[TreeNode]) -> bool:
            if not t:
                return False
            return match(t, head) or search(t.left) or search(t.right)

        return search(root)
```

Tags: #binary_tree #dfs 

RL: 

Considerations:
