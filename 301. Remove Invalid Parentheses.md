2025-08-14 17:27

Link: https://leetcode.com/problems/remove-invalid-parentheses/description/?envType=company&envId=millennium&favoriteSlug=millennium-all

Problem: 
Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return _a list of **unique strings** that are valid with the minimum number of removals_. You may return the answer in **any order**.

**Example 1:**
**Input:** s = "()())()"
**Output:** ["(())()","()()()"]

**Example 2:**
**Input:** s = "(a)())()"
**Output:** ["(a())()","(a)()()"]

**Example 3:**
**Input:** s = ")("
**Output:** [""]

**Constraints:**

- `1 <= s.length <= 25`
- `s` consists of lowercase English letters and parentheses `'('` and `')'`.
- There will be at most `20` parentheses in `s`.

Intuition:

Solution:
dfs + precompute
```python
from functools import lru_cache
from typing import List

class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        # 1) compute minimal deletions
        rmL = rmR = 0
        for ch in s:
            if ch == '(':
                rmL += 1
            elif ch == ')':
                if rmL > 0:
                    rmL -= 1
                else:
                    rmR += 1
        n = len(s)
        @lru_cache(None)
        def dp(i: int, open_cnt: int, rl: int, rr: int):
            # returns a frozenset of valid suffixes from state
            if rl < 0 or rr < 0:            # overspent deletions
                return frozenset()
            if i == n:
                if open_cnt == 0 and rl == 0 and rr == 0:
                    return frozenset([""])
                return frozenset()

            ch = s[i]
            res = set()
            rem = n - i - 1
            # quick infeasibility prune: need at least rl+rr deletions left
            if rl + rr > rem + 1:
                return frozenset()

            if ch == '(':
                # drop it
                for suf in dp(i + 1, open_cnt, rl - 1, rr):
                    res.add(suf)
                # keep it
                for suf in dp(i + 1, open_cnt + 1, rl, rr):
                    res.add('(' + suf)

            elif ch == ')':
                # drop it
                for suf in dp(i + 1, open_cnt, rl, rr - 1):
                    res.add(suf)
                # keep only if we have an unmatched '('
                if open_cnt > 0:
                    for suf in dp(i + 1, open_cnt - 1, rl, rr):
                        res.add(')' + suf)
            else:
                # letter: always keep
                for suf in dp(i + 1, open_cnt, rl, rr):
                    res.add(ch + suf)

            return frozenset(res)

        return list(dp(0, 0, rmL, rmR))
```


bfs
```python
from collections import deque

def is_valid(t: str) -> bool:
    bal = 0
    for c in t:
        if c == '(':
            bal += 1
        elif c == ')':
            if bal == 0:
                return False
            bal -= 1
    return bal == 0

class Solution:
    def removeInvalidParentheses(self, s: str):
        if not s:
            return [""]

        q = deque([s])
        visited = set([s])
        ans = []
        found = False

        while q:
            for _ in range(len(q)):
                cur = q.popleft()
                if is_valid(cur):
                    ans.append(cur)
                    found = True
                if found:
                    continue  # don’t expand deeper once we found a level

                # generate neighbors by removing one paren
                for i, ch in enumerate(cur):
                    if ch not in '()':
                        continue
                    # skip removing duplicate parens in a run to dedupe
                    if i > 0 and cur[i] == cur[i-1]:
                        continue
                    nxt = cur[:i] + cur[i+1:]
                    if nxt not in visited:
                        visited.add(nxt)
                        q.append(nxt)

            if found:
                break

        return ans if ans else [""]
```

Tags: #dfs #bfs #precomputation 

RL: 

Considerations:
