2025-10-04 15:33

Link: https://leetcode.com/problems/count-the-number-of-good-subarrays/description/?envType=company&envId=tiktok&favoriteSlug=tiktok-three-months

Problem: 
Given an integer array `nums` and an integer `k`, return _the number of **good** subarrays of_ `nums`.

A subarray `arr` is **good** if there are **at least** `k` pairs of indices `(i, j)` such that `i < j` and `arr[i] == arr[j]`.

A **subarray** is a contiguous **non-empty** sequence of elements within an array.

**Example 1:**
**Input:** nums = [1,1,1,1,1], k = 10
**Output:** 1
**Explanation:** The only good subarray is the array nums itself.

**Example 2:**
**Input:** nums = [3,1,4,3,2,2,4], k = 2
**Output:** 4
**Explanation:** There are 4 different good subarrays:
- [3,1,4,3,2,2] that has 2 pairs.
- [3,1,4,3,2,2,4] that has 3 pairs.
- [1,4,3,2,2,4] that has 2 pairs.
- [4,3,2,2,4] that has 2 pairs.

**Constraints:**
- `1 <= nums.length <= 105`
- `1 <= nums[i], k <= 109`

Intuition:
for each r ,we try to maximize the left pointer so that the window is still valid, and we count all the subarray that is larger than the current window until r (for  single iteration) (left pointer being smaller ....). and we dont have to reset left pointer since the windwo is minimally valid, we could always do ans += (l-1) for current l ,since no element is removed! 

Solution:
sliding window 
```python
from collections import defaultdict
from typing import List

class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if k == 0:
            return n * (n + 1) // 2

        cnt = defaultdict(int)
        pairs = 0
        l = 0
        ans = 0

        for r, x in enumerate(nums):
            # add right: x forms 'cnt[x]' new pairs with existing x's
            pairs += cnt[x]
            cnt[x] += 1

            # shrink to the minimal l that still keeps pairs >= k
            while l <= r and pairs - (cnt[nums[l]] - 1) >= k:
                y = nums[l]
                pairs -= (cnt[y] - 1)   # removing y destroys (freq-1) pairs
                cnt[y] -= 1
                l += 1

            if pairs >= k:
                ans += (l + 1)          # starts 0..l all work for this r

        return ans
```

Tags: #sliding_window #2_pointer 

RL: 

Considerations:
