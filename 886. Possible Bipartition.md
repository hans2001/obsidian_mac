2025-10-18 11:55

Link: https://leetcode.com/problems/possible-bipartition/description/?envType=company&envId=tiktok&favoriteSlug=tiktok-thirty-days

Problem: 
We want to split a group of `n` people (labeled from `1` to `n`) into two groups of **any size**. Each person may dislike some other people, and they should not go into the same group.

Given the integer `n` and the array `dislikes` where `dislikes[i] = [ai, bi]` indicates that the person labeled `ai` does not like the person labeled `bi`, return `true` _if it is possible to split everyone into two groups in this way_.

**Example 1:**

**Input:** n = 4, dislikes = [[1,2],[1,3],[2,4]]
**Output:** true
**Explanation:** The first group has [1,4], and the second group has [2,3].

**Example 2:**

**Input:** n = 3, dislikes = [[1,2],[1,3],[2,3]]
**Output:** false
**Explanation:** We need at least 3 groups to divide them. We cannot put them in two groups.

**Constraints:**

- `1 <= n <= 2000`
- `0 <= dislikes.length <= 104`
- `dislikes[i].length == 2`
- `1 <= ai < bi <= n`
- All the pairs of `dislikes` are **unique**.

Intuition:
we don't have to explicitly select groups and then possibly backtrack. we can just enforce the constraints and check if there is a valid situation for all constraint to persist. 
if 1 dislike 2, we have to separate them, so we add a consistent value x to the opposite neighbor, to make sure they don't belong. and for opponent for 1, such as 3 ,we do the same thing, so 2 and 3 can be a pair since they both union with 1 + x and they both hate number 1. However, if a constraint where 2 hates 3 as well ,we know we cannot fulfil all constraints, so bipartition is not possible. 

Solution:
Disjoint union set
```python
from typing import List

class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n + 1))
        self.rank = [0] * (n + 1)

    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # path compression
        return self.parent[x]

    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb: 
            return
        # union by rank
        if self.rank[ra] < self.rank[rb]:
            self.parent[ra] = rb
        elif self.rank[ra] > self.rank[rb]:
            self.parent[rb] = ra
        else:
            self.parent[rb] = ra
            self.rank[ra] += 1

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        # use 2n indices: 1..n are "group A", n+1..2n are "group B" (opposites)
        dsu = DSU(2 * n)
        for a, b in dislikes:
            # If a and b already forced to same side → impossible
            if dsu.find(a) == dsu.find(b):
                return False
            # Enforce opposites: a == opp(b) and b == opp(a)
            dsu.union(a, b + n)
            dsu.union(b, a + n)
        # Final contradiction check (optional since we check inside loop)
        for x in range(1, n + 1):
            if dsu.find(x) == dsu.find(x + n):
                return False
        return True
```

bfs + coloring
```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        # 1. Build the adjacency list
        graph = defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        
        color = {}  # person -> 0/1 group
        
        # 2. BFS over each connected component
        for person in range(1, n + 1):
            if person not in color:
                color[person] = 0
                queue = deque([person])
                
                while queue:
                    cur = queue.popleft()
                    for nei in graph[cur]:
                        if nei not in color:
                            color[nei] = 1 - color[cur]   # opposite group
                            queue.append(nei)
                        elif color[nei] == color[cur]:
                            # same color on both sides of dislike edge -> impossible
                            return False
        return True
```

Tags: #disjoin_set_union  #dfs #bfs #coloring

RL: 

Considerations:
