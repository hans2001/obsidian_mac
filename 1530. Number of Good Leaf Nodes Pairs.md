2025-12-24 20:40

Link: https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/

Problem: 
You are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`.

Return _the number of good leaf node pairs_ in the tree.

**Example 1:**
![](https://assets.leetcode.com/uploads/2020/07/09/e1.jpg)

**Input:** root = [1,2,3,null,4], distance = 3
**Output:** 1
**Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.

**Example 2:**
![](https://assets.leetcode.com/uploads/2020/07/09/e2.jpg)

**Input:** root = [1,2,3,4,5,6,7], distance = 3
**Output:** 2
**Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.

**Example 3:**
**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
**Output:** 1
**Explanation:** The only good pair is [2,5].

**Constraints:**

- The number of nodes in the `tree` is in the range `[1, 210].`
- `1 <= Node.val <= 100`
- `1 <= distance <= 10`

Intuition:
to make sure the pari of leaves computed only once, we do it at the LCA ,and for the LCA node to know how further away the leave node are compare to the node, we should return some kind of signature to inform the paretn node about node ,therefore a postorder nature is important for parent node to work on the computation at lsat. and the signature can be string or an arr, where the arr index represent the distance from leave node to current node ,and the value represent number of leaf node! 

so at each LCA, we check if leaves from 2 subtree can form a pari and whether their distance is smaller than the requirements! then u from a new signature for this node to return to the parent  (that is the core idea!)

Solution:
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def countPairs(self, root: Optional[TreeNode], distance: int) -> int:
        self.ans = 0

        def dfs(node):
            # returns arr[d] = number of leaves at distance d from this node
            if not node:
                return [0] * (distance + 1)

            # leaf node
            if not node.left and not node.right:
                arr = [0] * (distance + 1)
                arr[0] = 1
                return arr

            left = dfs(node.left)
            right = dfs(node.right)

            # count good pairs where LCA is this node
            for dl in range(distance + 1):
                if left[dl] == 0:
                    continue
                for dr in range(distance + 1):
                    if right[dr] == 0:
                        continue
                    if dl + dr + 2 <= distance:
                        self.ans += left[dl] * right[dr]

            # build distances for parent (shift by +1)
            res = [0] * (distance + 1)
            for d in range(distance):
                res[d + 1] = left[d] + right[d]

            return res

        dfs(root)
        return self.ans
```

Tags: #dfs #arr #LCA

RL: 

Considerations:
