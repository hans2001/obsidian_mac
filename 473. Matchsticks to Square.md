2025-05-01 11:26

Link:https://leetcode.com/problems/matchsticks-to-square/description/

Problem: 
You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**.

Return `true` if you can make this square and `false` otherwise.

Intuition:
backtrack
similar to the [[Partition to K Equal Sum Subsets]], we should have 4 subset of equal sum in order to form a valid square! 
or 
we can have a sums arr and try to group the sticks to either one in order to reach target! just like the code below! 





Solution:
Backtrack
```python
def makesquare(self, nums):
    """
    :type nums: List[int]
    :rtype: bool
    """
    if not nums:
        return False
    L = len(nums)
    perimeter = sum(nums)
    possible_side =  perimeter // 4
    if possible_side * 4 != perimeter:
        return False
    nums.sort(reverse=True)
    # This array represents the 4 sides and their current lengths
    sums = [0 for _ in range(4)]
    # Our recursive dfs function.
    def dfs(index):
        if index == L:
            # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.
            return sums[0] == sums[1] == sums[2] == possible_side
        # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are >= the size of the current matchstick)
        for i in range(4):
            # If this matchstick can fir in the space left for the current side
            if sums[i] + nums[index] <= possible_side:
                # Recurse
                sums[i] += nums[index]
                if dfs(index + 1):
                    return True
                # Revert the effects of recursion because we no longer need them for other recursions.
                sums[i] -= nums[index]
        return False        
    return dfs(0)
```

DP
```python

```

Complexity:
Time: 
we have n sticks and for each stick ,we have 4 possibilities for it to be explored, so time complexity for the naive backtracking solution would be 4^N

Space:
O(n) for the used array if any!, constant space for the sums arr! O(N) for the deepest recursive call! 

Tags: #backtracking #dp #1d_dp 

RL: [[Partition to K Equal Sum Subsets]]

Considerations:
