2025-08-25 10:43

Link: https://leetcode.com/problems/brightest-position-on-street/?envType=company&envId=tiktok&favoriteSlug=tiktok-thirty-days

Problem: 
A perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array `lights`. Each `lights[i] = [positioni, rangei]`indicates that there is a street lamp at position `positioni` that lights up the area from `[positioni - rangei, positioni + rangei]` (**inclusive**).

The **brightness** of a position `p` is defined as the number of street lamp that light up the position `p`.

Given `lights`, return _the **brightest** position on the_ _street. If there are multiple brightest positions, return the **smallest** one._

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/09/28/image-20210928155140-1.png)

**Input:** lights = [[-3,2],[1,2],[3,3]]
**Output:** -1
**Explanation:**
The first street lamp lights up the area from [(-3) - 2, (-3) + 2] = [-5, -1].
The second street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].
The third street lamp lights up the area from [3 - 3, 3 + 3] = [0, 6].

Position -1 has a brightness of 2, illuminated by the first and second street light.
Positions 0, 1, 2, and 3 have a brightness of 2, illuminated by the second and third street light.
Out of all these positions, -1 is the smallest, so return it.

**Example 2:**
**Input:** lights = [[1,0],[0,1]]
**Output:** 1
**Explanation:**
The first street lamp lights up the area from [1 - 0, 1 + 0] = [1, 1].
The second street lamp lights up the area from [0 - 1, 0 + 1] = [-1, 1].

Position 1 has a brightness of 2, illuminated by the first and second street light.
Return 1 because it is the brightest position on the street.

**Example 3:**
**Input:** lights = [[1,2]]
**Output:** -1
**Explanation:**
The first street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].

Positions -1, 0, 1, 2, and 3 have a brightness of 1, illuminated by the first street light.
Out of all these positions, -1 is the smallest, so return it.

**Constraints:**
- `1 <= lights.length <= 105`
- `lights[i].length == 2`
- `-108 <= positioni <= 108`
- `0 <= rangei <= 108`

Intuition:
first we have to know the interval the light cover ,and we record the interval end points as key in the difference map, then for each key, we track it brightness, since we record the point where brightness changes, we should be able to record the min position that have the largest brightness, that is why the algo works! 

Solution:
```python
from collections import defaultdict
from typing import List

class Solution:
    def brightestPosition(self, lights: List[List[int]]) -> int:
        events = defaultdict(int)
        for pos, cov in lights:
            L, R = pos - cov, pos + cov
            events[L] += 1
            events[R + 1] -= 1  # end is inclusive

        curr = 0
        best = -1
        ans = 0

        for x in sorted(events.keys()):
            curr += events[x]
            if curr > best:
                best = curr
                ans = x  # first (smallest) x reaching this brightness

        return ans
```

Tags: #line_sweep #dict 

RL: 

Considerations:
