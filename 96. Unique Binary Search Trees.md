2025-12-24 16:04

Link:

Problem: 
Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

**Input:** n = 3
**Output:** 5

**Example 2:**

**Input:** n = 1
**Output:** 1

**Constraints:**
- `1 <= n <= 19`v

Intuition:
> **dp[i] counts BST shapes with i nodes; we try every possible left/right split and sum all valid combinations.**
> 
> **BST structure is “choose a root, then independently choose left and right subtrees”, which forces a split-and-combine DP.**


key idea is that subtree in bst must be bst as well, that is why we can use the dp structure 

![[Screenshot 2025-12-24 at 4.05.33 PM.png]]

n = 2 

| **Left** | **Right** | **Ways**          |
| -------- | --------- | ----------------- |
| 0        | 1         | dp[0] * dp[1] = 1 |
| 1        | 0         | dp[1] * dp[0] = 1 |

n = 3

| **Left nodes** | **Right nodes** | **# of trees**    |
| -------------- | --------------- | ----------------- |
| 0              | 2               | dp[0] * dp[2] = 2 |
| 1              | 1               | dp[1] * dp[1] = 1 |
| 2              | 0               | dp[2] * dp[0] = 2 |

Solution:
```python
dp = [0] * (n + 1)
dp[0] = dp[1] = 1

for nodes in range(2, n + 1):
    for left in range(nodes):
        right = nodes - 1 - left
        dp[nodes] += dp[left] * dp[right]
```

Tags: #math #dp  #calatan_numbers

RL: 

Considerations:
