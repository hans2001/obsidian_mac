2025-11-27 14:09

Link: https://leetcode.com/contest/weekly-contest-477/problems/concatenate-non-zero-digits-and-multiply-by-sum-ii/

Problem: 
You are given a string s of length m consisting of digits. You are also given a 2D integer array queries, where queries[i] = [li, ri].

For each queries[i], extract the substring s[li..ri]. Then, perform the following:

Form a new integer x by concatenating all the non-zero digits from the substring in their original order. If there are no non-zero digits, x = 0.
Let sum be the sum of digits in x. The answer is x * sum.
Return an array of integers answer where answer[i] is the answer to the ith query.

Since the answers may be very large, return them modulo 109 + 7.

**Example 1:**
Input: s = "10203004", queries = [[0,7],[1,3],[4,6]]
Output: [12340, 4, 9]

Explanation:
s[0..7] = "10203004"
x = 1234
sum = 1 + 2 + 3 + 4 = 10
Therefore, answer is 1234 * 10 = 12340.
s[1..3] = "020"
x = 2
sum = 2
Therefore, the answer is 2 * 2 = 4.
s[4..6] = "300"
x = 3
sum = 3
Therefore, the answer is 3 * 3 = 9.

**Example 2:**
Input: s = "1000", queries = [[0,3],[1,1]]
Output: [1, 0]

Explanation:
s[0..3] = "1000"
x = 1
sum = 1
Therefore, the answer is 1 * 1 = 1.
s[1..1] = "0"
x = 0
sum = 0
Therefore, the answer is 0 * 0 = 0.

**Example 3:**
Input: s = "9876543210", queries = [[0,9]]
Output: [444444137]

Explanation:
s[0..9] = "9876543210"
x = 987654321
sum = 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45
Therefore, the answer is 987654321 * 45 = 44444444445.
We return 44444444445 modulo (109 + 7) = 444444137.
Â 
Constraints:
1 <= m == s.length <= 105
s consists of digits only.
1 <= queries.length <= 105
queries[i] = [li, ri]
0 <= li <= ri < m

Intuition:
use various forms of prefix sum, and use pos to record index for non_invalid_digits, and use prev and next to skip the invalid digits positions, and use the index we got from next and prev to query the valid_digits arr! with valid digit arr index, if we turn it into string, it would take O(n * k) where n is number of queries, we want to turn O(k) to O(1). 

Therefore, we build the val and pow10 arr. val arr help aggregate number from valid_digits, by using val[i+1] = val[i] * 10 + int(T[i]) % MOD. however, we are aggregating number in  prefix format, where in real query, we want portion of the aggregation only (given l and r in query), that is why we need pow10 to shifting the number to left to get the portion of the aggregate number that we want! (tricky!)

Solution:
```python
class Solution:
    def sumAndMultiply(self, s: str, queries: List[List[int]]) -> List[int]:
        ans = [ ]
        MOD = 10 ** 9 + 7
        n = len(s)
        prefix_sm = [0] * (n+1)
        T = [ ]
        digit_pointer = 0 
        pos = [0] * n
        prev =[-1] * n 
        last = -1
        
        for i in range( n ) : 
            if s[i] != '0':
                last = i
            prev[i] = last
        last = -1
        next =[-1] * n 
        
        for i in range( n -1 , -1, -1 ) : 
            if s[i] != '0':
                last = i
            next[i] = last
        
        for i in range ( n ) :
            if s[i] != '0': 
                T.append(s[i])
                pos[i] = digit_pointer
                digit_pointer += 1
            else: 
                pos[i] = -1 
            prefix_sm[i+1] = prefix_sm[i] + int(s[i])
        
        val = [0] * (len(T) + 1)
        val[0] = 0
        for i in range(len(T)):
            val[i+1] = (val[i] * 10 + int(T[i])) % MOD
        
        pow10 = [0] * (len(T) + 1)
        pow10[0] = 1
        for i in range(1, len(T)+1):
            pow10[i] = (pow10[i-1] * 10) % MOD
        
        for query in queries: 
            l,r = query
            sum = prefix_sm[r + 1] - prefix_sm[l]
            i, j = next[l], prev[r]
            if i == -1 or i > j or i > r : 
                ans.append( 0 )
                continue
            a,b = pos[i],pos[j]
            length = b - a + 1
            x = (val[b+1] - val[a] * pow10[length]) % MOD
            temp = (x * sum) % MOD
            ans.append( temp ) 
        return ans
```

Tags: #prefix_sum 

RL: 

Considerations:
