2025-05-22 11:22

Link: https://leetcode.com/problems/path-with-maximum-probability/description/

Problem: 
You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.

Given two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.

If there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e-5**.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png)**

**Input:** n = 3, edges = [ [0,1],[1,2],[0,2] ], succProb = [0.5,0.5,0.2], start = 0, end = 2
**Output:** 0.25000
**Explanation:** There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png)**

**Input:** n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
**Output:** 0.30000

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png)**

**Input:** n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
**Output:** 0.00000
**Explanation:** There is no path between 0 and 2.

Intuition:
Dijkstra:
[![Logarithms | A minimum of blind calculation](https://mathsmartinthomas.wordpress.com/wp-content/uploads/2016/10/04blog1.gif)
the value of p falls within 0 to 1, so the log value of that would be negative , there fore it is better we take negative log of the original weight to get maintain the positive edge weight! Form the reverse property, we know that we should minimize the sum of the negative log sum in order to get the maximum probability, so now we can use the standard Dijkstra algorithm

Solution:
Dijkstra:
```python
from math import log10
from heapq import heappush, heappop

class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:
        # Create adjacency list
        adj = [[] for _ in range(n)]
        
        dist = [float('inf')] * n
        dist[start_node] = 0
        
        for index, (source, end) in enumerate(edges):
            prob = succProb[index]
            # Skip zero probability edges or handle them specially
            if prob > 0:
                # Transform probability to negative log
                weight = -log10(prob)
                adj[source].append((weight, end))
                adj[end].append((weight, source))
            # If prob is 0, we can skip adding this edge entirely
        
        # Min heap for Dijkstra's
        hp = [(0, start_node)]
        
        while hp:
            weight, node = heappop(hp)
            
            # Skip if we've found a better path already
            if weight > dist[node]:
                continue
                
            # If we've reached the end node, we're done
            if node == end_node:
                return 10 ** (-dist[end_node])
            
            # Explore neighbors
            for ne_weight, ne_node in adj[node]:
                # New weight = current weight + edge weight
                new_weight = weight + ne_weight
                
                # If we found a better path
                if new_weight < dist[ne_node]:
                    dist[ne_node] = new_weight
                    heappush(hp, (new_weight, ne_node))
        
        # If we can't reach end_node
        return 0.0
```

bellman ford
```python
from math import log10

class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:
        # Initialize distances: 0 for start_node, infinity for others
        weights = [float('inf')] * n
        weights[start_node] = 0  # log(1) = 0
        
        # Bellman-Ford algorithm: V-1 iterations
        for _ in range(n - 1):
            # Flag to check if any updates were made
            updated = False
            
            # Process all edges
            for index, (source, target) in enumerate(edges):
                prob = succProb[index]
                
                # Skip zero probability edges
                if prob <= 0:
                    continue
                    
                weight = -log10(prob)
                
                # Process source -> target
                if weights[source] != float('inf') and weights[source] + weight < weights[target]:
                    weights[target] = weights[source] + weight
                    updated = True
                
                # Process target -> source (undirected graph)
                if weights[target] != float('inf') and weights[target] + weight < weights[source]:
                    weights[source] = weights[target] + weight
                    updated = True
            
            # If no updates were made in this iteration, we can stop early
            if not updated:
                break
        
        # Convert back from log space to probability
        return 0 if weights[end_node] == float('inf') else 10 ** (-weights[end_node])
```

Complexity:
bellman ford: 
Time: 
O(n * m) n is number of nodes and m is numberof edges
Space: 
O(n) store shortest dist form source node to current node

dijkstra: 
Time: 
O(n+m * log n) 
build adj list from all edges takes O(m) time
worse case ,each node would be pushed into the heap once, which takes O(n * logn) 
each edge is considered once which takes O(m * logn) time
Space:
O(n) for the adj list and O(m) for the maxProb arr! 

Tags: #dijkstra #google #min-heap #logarithmic 

RL: [[Dijkstra]]

Considerations:
understand the shortest path faster algorithm and how bellman ford can be applied here 