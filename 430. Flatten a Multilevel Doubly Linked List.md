2025-04-17 15:28

Link: https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/description/?envType=company&envId=bloomberg&favoriteSlug=bloomberg-thirty-days

Problem: 
You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional **child pointer**. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a **multilevel data structure** as shown in the example below.

Given the `head` of the first level of the list, **flatten** the list so that all the nodes appear in a single-level, doubly linked list. Let `curr` be a node with a child list. The nodes in the child list should appear **after** `curr` and **before** `curr.next` in the flattened list.

Return _the_ `head` _of the flattened list. The nodes in the list must have **all** of their child pointers set to_ `null`.

Intuition:
we use stack to store the original next node, then as we iterate through the list at first level, if we encounter node with child, we set next node to child node, and child_node prev to be the current node, and we goes to the next node as usual, as the child list reaching an end!, we set end of child list to be the original node, in both directions, and continue with the list by traversing to the next node! 

Solution:
```python
class Solution(object):
    def flatten(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head:
            return head
            
        # Use a dummy pointer to track the current position
        dummy = Node(0, None, head, None)
        # Stack to keep track of next nodes when we encounter children
        stack = []
        curr = dummy
        prev = dummy
        
        # Iterate through the list
        while curr:
            if curr.child:
                # If there's a next node, save it to the stack
                if curr.next:
                    stack.append(curr.next)
                
                # Connect curr to its child
                curr.next = curr.child
                curr.child.prev = curr
                curr.child = None  # Remove the child pointer
            
            # Move to the next node
            prev = curr
            curr = curr.next
            
            # If we've reached the end but have nodes in the stack
            if not curr and stack:
                next_node = stack.pop()
                prev.next = next_node
                next_node.prev = prev
                curr = next_node
                
        return dummy.next
```

Tags: #linked_list #doubly_linked_list #stack 

RL: 

Considerations:
