进程和线程? 线程的轻量级的体现在哪里?: 一个进程可以有多个线程, 线程是CPU调度的最小单位, 进程是资源分配的最小单位. 轻量级的话, 进程是静态的只用来分配资源的, 线程是动态的用来执行指令的.

线程crash进程会不会crash: 在Java语言的话, 线程crash并不会导致进程crash, 不过进程内不同线程之间的内存是共享的, 一个线程的crash可能导致其他线程用到的内存访问到不正确的数据, 然后导致其他线程出现crash

死锁了解吗? 说一下死锁产生的四个必要条件?有什么算法能避免死锁吗(银行家算法): 四个必要条件: 互斥(一个资源一次只能分配给一个线程使用), 不可剥夺(一个线程不能强行占有其他线程已经占有的), 请求和保持(一个线程在等待其他进程释放资源的同时，继续占有已经拥有的资源), 循环等待条件(A等B等C等A)

操作系统中cpu调度算法有哪些? 你觉得其中最好的一种是?: 首先是分为抢占和非抢占, 具体有:先进先执行FCFS/最短优先SJF/优先权＊＊＊转法(隔一段时间被迫交出CPU)...

操作系统IO模型: 同步阻塞/同步非阻塞(轮询:隔一会儿瞄一眼进度条/IO多路复用:poll&epoll机制:Handler?)/异步非阻塞(回调式)/异步阻塞(Kotlin协程suspend底层原理利用了Continuation实现了CPS转换,回调地狱应该算异步阻塞)

同步阻塞: 从开始阻塞到结束.
同步非阻塞: 开始到资源就绪轮询,资源拷贝阻塞.
IO多路复用: 开始到资源阻塞, 资源拷贝阻塞, 两段分别阻塞.
进程通信方式: 管道(只能在有亲缘关系进程间单向流动), 有名管道(允许无亲缘关系进程间单向流动), 消息队列, 共享内存, 信号量(控制多个进程对共享资源的访问,常用于文件锁), 套接字(可用于网络), 信号(通知进程某个事件已经发生)

解释性语言: Java编译成class, 在不同平台使用不同虚拟机解释执行. 编译型语言: c语言编译成二进制文件, 不同平台可执行的二进制文件不同.

架构? MVVM/MVP 区别:(MVC: View触发事件传递给Controller通知Model数据变化刷新View. MVP: MV彻底解耦, Presenter持有两者的接口进行操作. MVVM: MV彻底解耦, VM实现数据双向绑定, 比如Google的Databinding, 这时我们其实还需要写BindAdapter)

https与http的区别, 数字签名?: 多了一层 TLS/SSL, 数字签名将服务器发来的密文用签发机构的公钥解密, 然后和服务器的信息的hash值进行对比

DNS解析怎么做的? DNS劫持如何避免: DNS解析就是根据指定的域名, 记录类型(A,AAAA,CNAME,MX,NS), 记录值找到指定的服务器或跳转到其他域名. 避免DNS劫持可以在OkHttpClient中自定义自己的dns

http状态码: 100/102continue, 206分段内容, 301永久/301临时重定向/304 NotModified, 401未授权/403Forbidden服务器拒绝请求/404NotFound, 500服务器内部错误/502网关错误/503服务暂时不可用

http2多路复用: 基于二进制分帧层, HTTP消息被分解为独立的帧并行发送出去, 最后在另一端根据流ID重新组合

http几个版本的不同: 1.1: 多条连接承载多个请求, 2.0: 单条连接多路复用, 3.0: 基于QUIC实现快速可靠的UDP连接

get与post请求的区别? get与post携带数据的区别: get往往使用FormUrlEncoded这种方式将请求参数编码在url中, post往往会在body中包含数据. 且get请求一般带有缓存, post没有. get发送一次, post会先发送一次header, 服务端响应100 continue, 然后再发送真实数据, 响应 200

浏览器输入url发生了什么: 构建请求/DNS解析/发起TCP连接/发送HTTP请求/服务端响应HTTP请求/客户端处理请求

TCP原理, 如何实现可靠传输, 除了三次握手和四次挥手还有哪些机制?: ACK(服务端返回收到的最后一次正确的seq+1), 流量控制, 拥塞控制

为什么要三次握手/四次挥手:

三次握手: SYN->SYN+ACK->ACK, 如果变成两次握手, 如果第一次SYN包发送出去但是暂未成功建立连接, 而在客户端重试之后原来失效的连接又被成功发到了服务器使得服务器又使用原来的SYN包建立起了连接, 不符合预期.
四次挥手: FIN->ACK,FIN->ACK, 其中一方通知关闭之后另一方回应收到, 然后等待成功关闭后回应FIN包, 然后另一端回应ACK, 连接结束.
tcp长连接和http长连接区别: HTTP header(Connection: keep-alive), 指的是一个连接会保持一段时间, 而不是传输完数据就直接断开. TCP长连接指的是TCP保活计时器, HTTP的长连接本质上是TCP的长连接, TCP的长连接通过心跳包建立.

UDP如何实现可靠传输: QUIC: 基于UDP,减少了握手时间/避免队头阻塞的多路复用

怎么优化首页加载速度(从数据传输方面):(使用http3.0, 加入缓存机制, protobuf, 预加载机制, 服务端优化查询策略, dns解析存储ip, 跳过查找过程服务端进行压缩, 数据分页传递...)

说一下你熟悉的设计模式?: Factory/Builder/Adapter/Observer/Proxy/Singleton...

设计模式六大原则:开闭(扩展开放,修改关闭), 里氏代换(基类可以出现的地方,子类一定可以替换), 依赖反转(面向切面编程而不是具体的实现), 接口隔离(使用多个隔离接口解耦), 最少知道(尽可能少的与其他实体相互作用,系统功能模块相对独立), 合成复用(使用组合而不是继承)

computer network 
![[Pasted image 20250901110644.png]]


- **TCP（Transmission Control Protocol，传输控制协议 ）**：提供 **面向连接** 的，**可靠** 的数据传输服务。
- **UDP（User Datagram Protocol，用户数据协议）**：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效。


# http vs https
- **端口号**：HTTP 默认是 80，HTTPS 默认是 443。
- **URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
- **安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。
- **SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。