2026-01-09 14:31

Link: https://leetcode.com/problems/trim-a-binary-search-tree/description/

Problem: 
Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lies in `[low, high]`. Trimming the tree should **not** change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a **unique answer**.

Return _the root of the trimmed binary search tree_. Note that the root may change depending on the given bounds.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

**Input:** root = [1,0,2], low = 1, high = 2
**Output:** [1,null,2]

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

**Input:** root = [3,0,4,null,2,null,null,1], low = 1, high = 3
**Output:** [3,2,null,1]

**Constraints:**
- The number of nodes in the tree is in the range `[1, 104]`.
- `0 <= Node.val <= 104`
- The value of each node in the tree is **unique**.
- `root` is guaranteed to be a valid binary search tree.
- `0 <= low <= high <= 104`

failure: 
dont know how to connect node to grandchildren, -> recursive call return grandchildren node that is not pruned! and for each valid node, u provide a mechanism for it to connect with potentially new child node! 

Intuition:
We recursively trim the tree, and whenever a node is out of range, we replace it with the only subtree that could still contain valid values, using the BST ordering (if val < lower bound ,left subtree dont have valid node ,otherwise it is already bigger right subtree dont have shit! ) to skip everything else.

Solution:
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: Optional[TreeNode]
        :type low: int
        :type high: int
        :rtype: Optional[TreeNode]
        """
        def dfs(node):
            if not node:
                return None

            # Node value is too small: discard node and its left subtree
            if node.val < low:
                return dfs(node.right)

            # Node value is too large: discard node and its right subtree
            if node.val > high:
                return dfs(node.left)

            # Node is within range: trim its children
            node.left = dfs(node.left)
            node.right = dfs(node.right)

            return node
        return dfs(root)
```

Tags: #bst #recursion #structural #tree #binary_search_tree #prune 

RL: 

Considerations:
