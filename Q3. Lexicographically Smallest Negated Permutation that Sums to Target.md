2025-12-01 14:41

Link: https://leetcode.com/contest/biweekly-contest-170/problems/lexicographically-smallest-negated-permutation-that-sums-to-target/description/

Problem: 
You are given a positive integer n and an integer target.
Return the lexicographically smallest array of integers of size n such that:

The sum of its elements equals target.
The absolute values of its elements form a permutation of size n.
If no such array exists, return an empty array.

A permutation of size n is a rearrangement of integers 1, 2, ..., n.

Example 1:
Input: n = 3, target = 0
Output: [-3,1,2]

Explanation:
The arrays that sum to 0 and whose absolute values form a permutation of size 3 are:
[-3, 1, 2]
[-3, 2, 1]
[-2, -1, 3]
[-2, 3, -1]
[-1, -2, 3]
[-1, 3, -2]
[1, -3, 2]
[1, 2, -3]
[2, -3, 1]
[2, 1, -3]
[3, -2, -1]
[3, -1, -2]
The lexicographically smallest one is [-3, 1, 2].

Example 2:
Input: n = 1, target = 10000000000
Output: []

Explanation:
There are no arrays that sum to 10000000000 and whose absolute values form a permutation of size 1. Therefore, the answer is [].

Constraints:
1 <= n <= 105
-1010 <= target <= 1010

Intuition:
total sum of arr size form 1 to n is S (1+2+3+...n)
then we compute subset sum x = s - target / 2
It is the total amount of “sum-reduction” you need to create by flipping numbers negative.
```code
+i  -->  -i (not only reset to 0 ,we deduct it, so delta is -2 * i)
change = -2*i
```
But since flipping i reduces the sum by **2i**, you divide by 2

we use x to find number that should be negative in the final sequence
by greedy, we can use the largest number to deduct x first , until x is 0

then rest for the number should be positiv , just build the arr then sort the final result ascendingly, and it should be the lexicographically smallest permutation of array for size n (where absolute values of its elements form a permutation of size n.)

Solution:
```python
class Solution:
    def lexSmallestNegatedPerm(self, n: int, target: int) -> List[int]:
        s =  (n * (n + 1)) // 2
        x = (s - target) // 2
        if abs(target) > s:
            return []
        if (s - target) % 2 != 0:
            return []
        negatives = set()
        for j in range( n , 0 , -1 ) :
            if j <= x : 
                x -= j
                negatives.add( j )
            if x == 0: 
                break 
        if x != 0:
            return []
        res = [ -1 * i for i in negatives]
        res.sort( )
        for i in range( 1 , n+1 ): 
            if i in negatives: 
                continue
            res.append( i )
        return res
obsi

RL: 

Considerations:
