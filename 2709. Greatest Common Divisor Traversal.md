2025-05-23 15:54

Link: https://leetcode.com/problems/greatest-common-divisor-traversal/description/

Problem: 
You are given a **0-indexed** integer array `nums`, and you are allowed to **traverse** between its indices. You can traverse between index `i` and index `j`, `i != j`, if and only if `gcd(nums[i], nums[j]) > 1`, where `gcd` is the **greatest common divisor**.

Your task is to determine if for **every pair** of indices `i` and `j` in nums, where `i < j`, there exists a **sequence of traversals** that can take us from `i` to `j`.

Return `true` _if it is possible to traverse between all such pairs of indices,_ _or_ `false`_otherwise._

Intuition:
find out index for numbers who share the same prime factor, which mean they have gcd > 1, and we connect them with disjoint union set to construct direct and indirect edge.after that we confirm if all index belong to a single component, which mean\ we can traverse the arr for every pair of indexes! 

Solution:
prime factors + dsu
```python
import math
from collections import defaultdict

class DSU:
    def __init__(self, n):
        self.Parent = list(range(n))
        self.Size = [1] * n
    
    def find(self, node):
        if self.Parent[node] != node:
            self.Parent[node] = self.find(self.Parent[node])
        return self.Parent[node]
    
    def union(self, u, v):
        pu = self.find(u)
        pv = self.find(v)
        if pu == pv:
            return False
        if self.Size[pu] < self.Size[pv]:
            pu, pv = pv, pu
        self.Size[pu] += self.Size[pv]
        self.Parent[pv] = pu
        return True

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        """More readable version with explicit variable names."""
        if len(nums) == 1:
            return True
        if 1 in nums:
            return False
            
        n = len(nums)
        dsu = DSU(n)
        
        # Map: prime_factor -> list of indices containing that prime
        prime_to_indices = defaultdict(list)
        
        # Build the mapping
        for index, number in enumerate(nums):
            prime_factors = self.get_prime_factors(number)
            for prime in prime_factors:
                prime_to_indices[prime].append(index)
        
        # Connect indices sharing prime factors
        for indices_with_same_prime in prime_to_indices.values():
            # Union consecutive pairs in the list
            for i in range(len(indices_with_same_prime) - 1):
                current_index = indices_with_same_prime[i]
                next_index = indices_with_same_prime[i + 1]
                dsu.union(current_index, next_index)
        
        # Check connectivity: all indices should have same root
        first_root = dsu.find(0)
        for i in range(1, n):
            if dsu.find(i) != first_root:
                return False
        return True
    
    def get_prime_factors(self, n):
        """Same as above - extract prime factors efficiently."""
        factors = set()
        
        # Handle even factor
        if n % 2 == 0:
            factors.add(2)
            while n % 2 == 0:
                n //= 2
        
        # Handle odd factors
        divisor = 3
        while divisor * divisor <= n:
            if n % divisor == 0:
                factors.add(divisor)
                while n % divisor == 0:
                    n //= divisor
            divisor += 2
        
        # Remaining prime
        if n > 1:
            factors.add(n)
            
        return factors
```

Complexity:
Time: 
prime factorization
finding prime number for each number takes O(√M) (constant work to remove the even factor from the number, and we test out odd factor from 3 up to sqrt(n), which is limited by the max number from the input list( max(n) == M)). We do this for n number, so it take O(n * sqrt(M)) time 

for building and checking connectivity, we spend O(n) time with near constant union operations for n numbers

so dominant term is O(n * sqrt(M))

Space: 
O(N) for the disjoint union set, and O(P) for prime factor dictionary


Tags: #prime_factors #google #disjoin_set_union 

RL: 

Considerations:
find_prime_factors func:
- **Handle 2’s first**
    - Any even number has 2 as a factor. By repeatedly dividing out 2 (`while n % 2 == 0`), you remove _all_ factors of 2 up front.
        
    - This both captures the prime 2 in your result list and reduces the problem to an odd integer—so you can skip every even trial thereafter.
        
- **Only test odd divisors up to √n**
    - Once you’ve removed 2’s, any remaining prime factors must be odd. So you start `f` at 3 and increment by 2 each loop.
        
    - You only need to check divisors up to √n. Why? If `n` still has a factor greater than √n, then its complementary factor would be smaller than √n and would already have been removed. So when `f * f > n`, you know no further smaller divisors exist.
        
- **Divide out each factor completely**
    - Inside the `while n % f == 0` inner loop, you keep dividing by `f` until it no longer divides. This ensures you record multiple copies (e.g. in 12, you record two 2’s then one 3).
        
- **What’s left is prime**
    - After removing all factors ≤ √original_n, if the remaining `n` is > 1, it can’t have any further divisors—so it _must_itself be prime. Appending it finishes your factor list.