2025-08-12 18:40

Link:

Problem: 
You are given two integer arrays value and limit, both of length n.

Initially, all elements are inactive. You may activate them in any order.

To activate an inactive element at index i, the number of currently active elements must be strictly less than limit[i].
When you activate the element at index i, it adds value[i] to the total activation value (i.e., the sum of value[i] for all elements that have undergone activation operations).
After each activation, if the number of currently active elements becomes x, then all elements j with limit[j] <= x become permanently inactive, even if they are already active.
Return the maximum total you can obtain by choosing the activation order optimally.

Constraints:

1 <= n == value.length == limit.length <= 105
1 <= value[i] <= 105​​​​​​​
1 <= limit[i] <= n©leetcode

Intuition:
update number of element bale to be activate when number of active element changed
use greedy ,we should pick the one with smaller limit first, so they dont expire, and for same limit, we should pick the one with higher value to add

Solution:
```python
from collections import deque
from heapq  import heappush ,heappop 
class Solution:
    def maxTotal(self, value: List[int], limit: List[int]) -> int:
        n = len( value )
        hp = []
        for i in range( n ) :
            heappush(  hp , (  limit[i], -1 * value[i] ) )
        active = 0
        res = 0
        q = deque ( )
        while True:
            if not hp: 
                break
            lim , value = heappop( hp )
            q.append( lim )
            res += (-1 * value) 
            l = len( q)
            while hp and hp[0][0] <= len( q ) :
                heappop( hp )
            while q and q[0] <= l: 
                q.popleft( )
        return res
```

Tags: #greedy #heap 

RL: 

Considerations:
