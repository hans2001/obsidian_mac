2025-04-22 15:21

Link: https://leetcode.com/problems/all-paths-from-source-to-target/description/?envType=company&envId=bloomberg&favoriteSlug=bloomberg-thirty-days

Problem: 
Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.

The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).

Intuition:
use backtracking to explore all path
base case is when the last node (target) reached! 
since this is a DAG, we dont have to worry about cycles! 

Solution:
```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:

        target = len(graph) - 1
        results = []

        def backtrack(curr_node, path):
            # if we reach the target, no need to explore further.
            if curr_node == target:
                results.append(list(path))
                return
            # explore the neighbor nodes one after another.
            for next_node in graph[curr_node]:
                path.append(next_node)
                backtrack(next_node, path)
                path.pop()
        # kick of the backtracking, starting from the source node (0).
        path = [0]
        backtrack(0, path)

        return results
```
- Time Complexity: O(2N⋅N)
    
    - As we calculate shortly before, there could be at most 2N−1−1 possible paths in the graph.
        
    - For each path, there could be at most N−2 intermediate nodes, _i.e._ it takes O(N) time to build a path.
        
    - To sum up, a **loose** upper-bound on the time complexity of the algorithm would be (2N−1−1)⋅O(N)=O(2N⋅N), where we consider it takes O(N) efforts to build each path.
        
- Space Complexity: O(N)
    
    - Since we also applied _recursion_ in the algorithm, the recursion could incur additional memory consumption in the function call stack. The stack can grow up to N consecutive calls. Meanwhile, along with the recursive call, we also keep the state of the current path, which could take another O(N) space. Therefore, in total, the recursion would require additional O(N) space.
        
    - However, apart from our algorithm, since at most we could have 2N−1−1 paths as the results and each path can contain up to N nodes, we need extra O(2N⋅N)space to store and return the results.

Tags: #backtracking 

RL: 

Considerations:
